{"version":3,"file":"js/260.219da49b.js","mappings":"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","sources":["webpack://graduate/./node_modules/ol/Disposable.js","webpack://graduate/./node_modules/ol/Image.js","webpack://graduate/./node_modules/ol/ImageState.js","webpack://graduate/./node_modules/ol/ImageTile.js","webpack://graduate/./node_modules/ol/Object.js","webpack://graduate/./node_modules/ol/ObjectEventType.js","webpack://graduate/./node_modules/ol/Observable.js","webpack://graduate/./node_modules/ol/Tile.js","webpack://graduate/./node_modules/ol/TileRange.js","webpack://graduate/./node_modules/ol/TileState.js","webpack://graduate/./node_modules/ol/ViewProperty.js","webpack://graduate/./node_modules/ol/centerconstraint.js","webpack://graduate/./node_modules/ol/resolutionconstraint.js","webpack://graduate/./node_modules/ol/View.js","webpack://graduate/./node_modules/ol/ViewHint.js","webpack://graduate/./node_modules/ol/array.js","webpack://graduate/./node_modules/ol/asserts.js","webpack://graduate/./node_modules/ol/color.js","webpack://graduate/./node_modules/ol/console.js","webpack://graduate/./node_modules/ol/coordinate.js","webpack://graduate/./node_modules/ol/dom.js","webpack://graduate/./node_modules/ol/easing.js","webpack://graduate/./node_modules/ol/events.js","webpack://graduate/./node_modules/ol/events/Event.js","webpack://graduate/./node_modules/ol/events/EventType.js","webpack://graduate/./node_modules/ol/events/Target.js","webpack://graduate/./node_modules/ol/extent.js","webpack://graduate/./node_modules/ol/extent/Relationship.js","webpack://graduate/./node_modules/ol/functions.js","webpack://graduate/./node_modules/ol/geom/Geometry.js","webpack://graduate/./node_modules/ol/geom/Point.js","webpack://graduate/./node_modules/ol/geom/LinearRing.js","webpack://graduate/./node_modules/ol/geom/Polygon.js","webpack://graduate/./node_modules/ol/geom/SimpleGeometry.js","webpack://graduate/./node_modules/ol/geom/flat/area.js","webpack://graduate/./node_modules/ol/geom/flat/closest.js","webpack://graduate/./node_modules/ol/geom/flat/contains.js","webpack://graduate/./node_modules/ol/geom/flat/deflate.js","webpack://graduate/./node_modules/ol/geom/flat/inflate.js","webpack://graduate/./node_modules/ol/geom/flat/interiorpoint.js","webpack://graduate/./node_modules/ol/geom/flat/intersectsextent.js","webpack://graduate/./node_modules/ol/geom/flat/reverse.js","webpack://graduate/./node_modules/ol/geom/flat/orient.js","webpack://graduate/./node_modules/ol/geom/flat/segments.js","webpack://graduate/./node_modules/ol/geom/flat/simplify.js","webpack://graduate/./node_modules/ol/geom/flat/transform.js","webpack://graduate/./node_modules/ol/has.js","webpack://graduate/./node_modules/ol/layer/Base.js","webpack://graduate/./node_modules/ol/layer/Layer.js","webpack://graduate/./node_modules/ol/layer/Property.js","webpack://graduate/./node_modules/ol/layer/TileProperty.js","webpack://graduate/./node_modules/ol/layer/BaseTile.js","webpack://graduate/./node_modules/ol/DataTile.js","webpack://graduate/./node_modules/ol/reproj/DataTile.js","webpack://graduate/./node_modules/ol/webgl/BaseTileRepresentation.js","webpack://graduate/./node_modules/ol/webgl.js","webpack://graduate/./node_modules/ol/webgl/Buffer.js","webpack://graduate/./node_modules/ol/webgl/TileTexture.js","webpack://graduate/./node_modules/ol/webgl/ContextEventType.js","webpack://graduate/./node_modules/ol/webgl/PostProcessingPass.js","webpack://graduate/./node_modules/ol/vec/mat4.js","webpack://graduate/./node_modules/ol/webgl/Helper.js","webpack://graduate/./node_modules/ol/renderer/webgl/Layer.js","webpack://graduate/./node_modules/ol/renderer/webgl/TileLayerBase.js","webpack://graduate/./node_modules/ol/renderer/webgl/TileLayer.js","webpack://graduate/./node_modules/ol/webgl/PaletteTexture.js","webpack://graduate/./node_modules/ol/style/expressions.js","webpack://graduate/./node_modules/ol/layer/WebGLTile.js","webpack://graduate/./node_modules/ol/math.js","webpack://graduate/./node_modules/ol/obj.js","webpack://graduate/./node_modules/ol/proj/Units.js","webpack://graduate/./node_modules/ol/proj/Projection.js","webpack://graduate/./node_modules/ol/proj/epsg3857.js","webpack://graduate/./node_modules/ol/proj/epsg4326.js","webpack://graduate/./node_modules/ol/proj/projections.js","webpack://graduate/./node_modules/ol/proj/transforms.js","webpack://graduate/./node_modules/ol/sphere.js","webpack://graduate/./node_modules/ol/proj.js","webpack://graduate/./node_modules/ol/render/Event.js","webpack://graduate/./node_modules/ol/render/EventType.js","webpack://graduate/./node_modules/ol/renderer/Layer.js","webpack://graduate/./node_modules/ol/reproj.js","webpack://graduate/./node_modules/ol/reproj/Tile.js","webpack://graduate/./node_modules/ol/reproj/Triangulation.js","webpack://graduate/./node_modules/ol/reproj/common.js","webpack://graduate/./node_modules/ol/rotationconstraint.js","webpack://graduate/./node_modules/ol/size.js","webpack://graduate/./node_modules/ol/structs/LRUCache.js","webpack://graduate/./node_modules/ol/tilecoord.js","webpack://graduate/./node_modules/ol/tilegrid/common.js","webpack://graduate/./node_modules/ol/transform.js","webpack://graduate/./node_modules/ol/util.js"],"sourcesContent":["/**\n * @module ol/Disposable\n */\n\n/**\n * @classdesc\n * Objects that need to clean up after themselves.\n */\nclass Disposable {\n  constructor() {\n    /**\n     * The object has already been disposed.\n     * @type {boolean}\n     * @protected\n     */\n    this.disposed = false;\n  }\n\n  /**\n   * Clean up.\n   */\n  dispose() {\n    if (!this.disposed) {\n      this.disposed = true;\n      this.disposeInternal();\n    }\n  }\n\n  /**\n   * Extension point for disposable objects.\n   * @protected\n   */\n  disposeInternal() {}\n}\n\nexport default Disposable;\n","/**\n * @module ol/Image\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport ImageState from './ImageState.js';\nimport {CREATE_IMAGE_BITMAP, IMAGE_DECODE} from './has.js';\nimport {listenOnce, unlistenByKey} from './events.js';\nimport {toPromise} from './functions.js';\n\n/**\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\n * @api\n */\n\n/**\n * @typedef {Object} ImageObject\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * For images that cover any extent and resolution (static images), the loader function should not accept\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\n * correct `extent`, `resolution` and `pixelRatio`.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\n * @api\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\n */\n\nclass ImageWrapper extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\n   * resolution will be assumed.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default|import(\"./Image.js\").Loader} stateOrLoader State.\n   */\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number|Array<number>|undefined}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n    this.state =\n      typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\n\n    /**\n     * @private\n     * @type {import('./DataTile.js').ImageLike|null}\n     */\n    this.image_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"./Image.js\").Loader}\n     */\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\n   * @return {import('./DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * @return {number} PixelRatio.\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\n   * @return {number|Array<number>} Resolution.\n   */\n  getResolution() {\n    return /** @type {number} */ (this.resolution);\n  }\n\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      if (this.loader) {\n        this.state = ImageState.LOADING;\n        this.changed();\n        const resolution = this.getResolution();\n        const requestResolution = Array.isArray(resolution)\n          ? resolution[0]\n          : resolution;\n        toPromise(() =>\n          this.loader(this.getExtent(), requestResolution, this.getPixelRatio())\n        )\n          .then((image) => {\n            if ('image' in image) {\n              this.image_ = image.image;\n            }\n            if ('extent' in image) {\n              this.extent = image.extent;\n            }\n            if ('resolution' in image) {\n              this.resolution = image.resolution;\n            }\n            if ('pixelRatio' in image) {\n              this.pixelRatio_ = image.pixelRatio;\n            }\n            if (\n              image instanceof HTMLImageElement ||\n              image instanceof ImageBitmap ||\n              image instanceof HTMLCanvasElement ||\n              image instanceof HTMLVideoElement\n            ) {\n              this.image_ = image;\n            }\n            this.state = ImageState.LOADED;\n          })\n          .catch((error) => {\n            this.state = ImageState.ERROR;\n            console.error(error); // eslint-disable-line no-console\n          })\n          .finally(() => this.changed());\n      }\n    }\n  }\n\n  /**\n   * @param {import('./DataTile.js').ImageLike} image The image.\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\n   * @param {number|Array<number>} resolution Resolution.\n   */\n  setResolution(resolution) {\n    this.resolution = resolution;\n  }\n}\n\n/**\n * @param {import('./DataTile.js').ImageLike} image Image element.\n * @param {function():any} loadHandler Load callback function.\n * @param {function():any} errorHandler Error callback function.\n * @return {function():void} Callback to stop listening.\n */\nexport function listenImage(image, loadHandler, errorHandler) {\n  const img = /** @type {HTMLImageElement} */ (image);\n  let listening = true;\n  let decoding = false;\n  let loaded = false;\n\n  const listenerKeys = [\n    listenOnce(img, EventType.LOAD, function () {\n      loaded = true;\n      if (!decoding) {\n        loadHandler();\n      }\n    }),\n  ];\n\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img\n      .decode()\n      .then(function () {\n        if (listening) {\n          loadHandler();\n        }\n      })\n      .catch(function (error) {\n        if (listening) {\n          if (loaded) {\n            loadHandler();\n          } else {\n            errorHandler();\n          }\n        }\n      });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\n\n/**\n * Loads an image.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n * @api\n */\nexport function load(image, src) {\n  return new Promise((resolve, reject) => {\n    function handleLoad() {\n      unlisten();\n      resolve(image);\n    }\n    function handleError() {\n      unlisten();\n      reject(new Error('Image load error'));\n    }\n    function unlisten() {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    }\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n    if (src) {\n      image.src = src;\n    }\n  });\n}\n\n/**\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n */\nexport function decodeFallback(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return IMAGE_DECODE\n    ? new Promise((resolve, reject) =>\n        image.decode().then(() => resolve(image), reject)\n      )\n    : load(image);\n}\n\n/**\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\n * the loaded image otherwise.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\n * @api\n */\nexport function decode(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return IMAGE_DECODE && CREATE_IMAGE_BITMAP\n    ? image.decode().then(() => createImageBitmap(image))\n    : decodeFallback(image);\n}\n\nexport default ImageWrapper;\n","/**\n * @module ol/ImageState\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3,\n  EMPTY: 4,\n};\n","/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   *\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/Object\n */\nimport Event from './events/Event.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport Observable from './Observable.js';\nimport {getUid} from './util.js';\nimport {isEmpty} from './obj.js';\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.\n */\nexport class ObjectEvent extends Event {\n  /**\n   * @param {string} type The event type.\n   * @param {string} key The property name.\n   * @param {*} oldValue The old value for `key`.\n   */\n  constructor(type, key, oldValue) {\n    super(type);\n\n    /**\n     * The name of the property whose value is changing.\n     * @type {string}\n     * @api\n     */\n    this.key = key;\n\n    /**\n     * The old value. To get the new value use `e.target.get(e.key)` where\n     * `e` is the event object.\n     * @type {*}\n     * @api\n     */\n    this.oldValue = oldValue;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types, ObjectEvent, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types, Return>} ObjectOnSignature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Most non-trivial classes inherit from this.\n *\n * This extends {@link module:ol/Observable~Observable} with observable\n * properties, where each property is observable as well as the object as a\n * whole.\n *\n * Classes that inherit from this have pre-defined properties, to which you can\n * add your owns. The pre-defined properties are listed in this documentation as\n * 'Observable Properties', and have their own accessors; for example,\n * {@link module:ol/Map~Map} has a `target` property, accessed with\n * `getTarget()` and changed with `setTarget()`. Not all properties are however\n * settable. There are also general-purpose accessors `get()` and `set()`. For\n * example, `get('target')` is equivalent to `getTarget()`.\n *\n * The `set` accessors trigger a change event, and you can monitor this by\n * registering a listener. For example, {@link module:ol/View~View} has a\n * `center` property, so `view.on('change:center', function(evt) {...});` would\n * call the function whenever the value of the center property changes. Within\n * the function, `evt.target` would be the view, so `evt.target.getCenter()`\n * would return the new center.\n *\n * You can add your own observable properties with\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\n * You can listen for changes on that property value with\n * `object.on('change:prop', listener)`. You can get a list of all\n * properties with {@link module:ol/Object~BaseObject#getProperties}.\n *\n * Note that the observable properties are separate from standard JS properties.\n * You can, for example, give your map object a title with\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\n * first will be a `hasOwnProperty`; the second will appear in\n * `getProperties()`. Only the second is observable.\n *\n * Properties can be deleted by using the unset method. E.g.\n * object.unset('foo').\n *\n * @fires ObjectEvent\n * @api\n */\nclass BaseObject extends Observable {\n  /**\n   * @param {Object<string, *>} [values] An object with key-value pairs.\n   */\n  constructor(values) {\n    super();\n\n    /***\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ObjectOnSignature<void>}\n     */\n    this.un;\n\n    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is\n    // the same as the order in which they were created.  This also helps to\n    // ensure that object properties are always added in the same order, which\n    // helps many JavaScript engines generate faster code.\n    getUid(this);\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.values_ = null;\n\n    if (values !== undefined) {\n      this.setProperties(values);\n    }\n  }\n\n  /**\n   * Gets a value.\n   * @param {string} key Key name.\n   * @return {*} Value.\n   * @api\n   */\n  get(key) {\n    let value;\n    if (this.values_ && this.values_.hasOwnProperty(key)) {\n      value = this.values_[key];\n    }\n    return value;\n  }\n\n  /**\n   * Get a list of object property names.\n   * @return {Array<string>} List of property names.\n   * @api\n   */\n  getKeys() {\n    return (this.values_ && Object.keys(this.values_)) || [];\n  }\n\n  /**\n   * Get an object of all property names and values.\n   * @return {Object<string, *>} Object.\n   * @api\n   */\n  getProperties() {\n    return (this.values_ && Object.assign({}, this.values_)) || {};\n  }\n\n  /**\n   * Get an object of all property names and values.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.values_;\n  }\n\n  /**\n   * @return {boolean} The object has properties.\n   */\n  hasProperties() {\n    return !!this.values_;\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {*} oldValue Old value.\n   */\n  notify(key, oldValue) {\n    let eventType;\n    eventType = `change:${key}`;\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n    eventType = ObjectEventType.PROPERTYCHANGE;\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {import(\"./events.js\").Listener} listener Listener.\n   */\n  addChangeListener(key, listener) {\n    this.addEventListener(`change:${key}`, listener);\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {import(\"./events.js\").Listener} listener Listener.\n   */\n  removeChangeListener(key, listener) {\n    this.removeEventListener(`change:${key}`, listener);\n  }\n\n  /**\n   * Sets a value.\n   * @param {string} key Key name.\n   * @param {*} value Value.\n   * @param {boolean} [silent] Update without triggering an event.\n   * @api\n   */\n  set(key, value, silent) {\n    const values = this.values_ || (this.values_ = {});\n    if (silent) {\n      values[key] = value;\n    } else {\n      const oldValue = values[key];\n      values[key] = value;\n      if (oldValue !== value) {\n        this.notify(key, oldValue);\n      }\n    }\n  }\n\n  /**\n   * Sets a collection of key-value pairs.  Note that this changes any existing\n   * properties and adds new ones (it does not remove any existing properties).\n   * @param {Object<string, *>} values Values.\n   * @param {boolean} [silent] Update without triggering an event.\n   * @api\n   */\n  setProperties(values, silent) {\n    for (const key in values) {\n      this.set(key, values[key], silent);\n    }\n  }\n\n  /**\n   * Apply any properties from another object without triggering events.\n   * @param {BaseObject} source The source object.\n   * @protected\n   */\n  applyProperties(source) {\n    if (!source.values_) {\n      return;\n    }\n    Object.assign(this.values_ || (this.values_ = {}), source.values_);\n  }\n\n  /**\n   * Unsets a property.\n   * @param {string} key Key name.\n   * @param {boolean} [silent] Unset without triggering an event.\n   * @api\n   */\n  unset(key, silent) {\n    if (this.values_ && key in this.values_) {\n      const oldValue = this.values_[key];\n      delete this.values_[key];\n      if (isEmpty(this.values_)) {\n        this.values_ = null;\n      }\n      if (!silent) {\n        this.notify(key, oldValue);\n      }\n    }\n  }\n}\n\nexport default BaseObject;\n","/**\n * @module ol/ObjectEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a property is changed.\n   * @event module:ol/Object.ObjectEvent#propertychange\n   * @api\n   */\n  PROPERTYCHANGE: 'propertychange',\n};\n\n/**\n * @typedef {'propertychange'} Types\n */\n","/**\n * @module ol/Observable\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport {listen, listenOnce, unlistenByKey} from './events.js';\n\n/***\n * @template {string} Type\n * @template {Event|import(\"./events/Event.js\").default} EventClass\n * @template Return\n * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature\n */\n\n/***\n * @template {string} Type\n * @template Return\n * @typedef {(type: Type[], listener: (event: Event|import(\"./events/Event\").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature\n */\n\n/**\n * @typedef {'change'|'error'} EventTypes\n */\n\n/***\n * @template Return\n * @typedef {OnSignature<EventTypes, import(\"./events/Event.js\").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires import(\"./events/Event.js\").default\n * @api\n */\nclass Observable extends EventTarget {\n  constructor() {\n    super();\n\n    this.on =\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\n        this.onInternal\n      );\n\n    this.once =\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\n        this.onceInternal\n      );\n\n    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.revision_ = 0;\n  }\n\n  /**\n   * Increases the revision counter and dispatches a 'change' event.\n   * @api\n   */\n  changed() {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n  getRevision() {\n    return this.revision_;\n  }\n\n  /**\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\n   * @protected\n   */\n  onInternal(type, listener) {\n    if (Array.isArray(type)) {\n      const len = type.length;\n      const keys = new Array(len);\n      for (let i = 0; i < len; ++i) {\n        keys[i] = listen(this, type[i], listener);\n      }\n      return keys;\n    }\n    return listen(this, /** @type {string} */ (type), listener);\n  }\n\n  /**\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\n   * @protected\n   */\n  onceInternal(type, listener) {\n    let key;\n    if (Array.isArray(type)) {\n      const len = type.length;\n      key = new Array(len);\n      for (let i = 0; i < len; ++i) {\n        key[i] = listenOnce(this, type[i], listener);\n      }\n    } else {\n      key = listenOnce(this, /** @type {string} */ (type), listener);\n    }\n    /** @type {Object} */ (listener).ol_key = key;\n    return key;\n  }\n\n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @protected\n   */\n  unInternal(type, listener) {\n    const key = /** @type {Object} */ (listener).ol_key;\n    if (key) {\n      unByKey(key);\n    } else if (Array.isArray(type)) {\n      for (let i = 0, ii = type.length; i < ii; ++i) {\n        this.removeEventListener(type[i], listener);\n      }\n    } else {\n      this.removeEventListener(type, listener);\n    }\n  }\n}\n\n/**\n * Listen for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\nObservable.prototype.on;\n\n/**\n * Listen once for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\nObservable.prototype.once;\n\n/**\n * Unlisten for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @api\n */\nObservable.prototype.un;\n\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\nexport function unByKey(key) {\n  if (Array.isArray(key)) {\n    for (let i = 0, ii = key.length; i < ii; ++i) {\n      unlistenByKey(key[i]);\n    }\n  } else {\n    unlistenByKey(/** @type {import(\"./events.js\").EventsKey} */ (key));\n  }\n}\n\nexport default Observable;\n","/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    let tile = this.interimTile;\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    if (!this.interimTile) {\n      return;\n    }\n\n    let tile = this.interimTile;\n\n    /**\n     * @type {Tile}\n     */\n    let prev = this;\n\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/TileState\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  /**\n   * Indicates that tile loading failed\n   * @type {number}\n   */\n  ERROR: 3,\n  EMPTY: 4,\n};\n","/**\n * @module ol/ViewProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  CENTER: 'center',\n  RESOLUTION: 'resolution',\n  ROTATION: 'rotation',\n};\n","/**\n * @module ol/centerconstraint\n */\nimport {clamp} from './math.js';\n\n/**\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\n */\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\n * (only during interaction and animation).\n * @return {Type} The constraint.\n */\nexport function createExtent(extent, onlyCenter, smooth) {\n  return (\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\n     * @param {number|undefined} resolution Resolution.\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @param {Array<number>} [centerShift] Shift between map center and viewport center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n     */\n    function (center, resolution, size, isMoving, centerShift) {\n      if (!center) {\n        return undefined;\n      }\n      if (!resolution && !onlyCenter) {\n        return center;\n      }\n      const viewWidth = onlyCenter ? 0 : size[0] * resolution;\n      const viewHeight = onlyCenter ? 0 : size[1] * resolution;\n      const shiftX = centerShift ? centerShift[0] : 0;\n      const shiftY = centerShift ? centerShift[1] : 0;\n      let minX = extent[0] + viewWidth / 2 + shiftX;\n      let maxX = extent[2] - viewWidth / 2 + shiftX;\n      let minY = extent[1] + viewHeight / 2 + shiftY;\n      let maxY = extent[3] - viewHeight / 2 + shiftY;\n\n      // note: when zooming out of bounds, min and max values for x and y may\n      // end up inverted (min > max); this has to be accounted for\n      if (minX > maxX) {\n        minX = (maxX + minX) / 2;\n        maxX = minX;\n      }\n      if (minY > maxY) {\n        minY = (maxY + minY) / 2;\n        maxY = minY;\n      }\n\n      let x = clamp(center[0], minX, maxX);\n      let y = clamp(center[1], minY, maxY);\n\n      // during an interaction, allow some overscroll\n      if (isMoving && smooth && resolution) {\n        const ratio = 30 * resolution;\n        x +=\n          -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +\n          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\n        y +=\n          -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +\n          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\n      }\n\n      return [x, y];\n    }\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} [center] Center.\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n */\nexport function none(center) {\n  return center;\n}\n","/**\n * @module ol/resolutionconstraint\n */\nimport {clamp} from './math.js';\nimport {getHeight, getWidth} from './extent.js';\nimport {linearFindNearest} from './array.js';\n\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(\n  resolution,\n  maxExtent,\n  viewportSize,\n  showFullExtent\n) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n\n  result *=\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n    1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /=\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n        ratio +\n      1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(\n  resolutions,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [minResolution] Minimum resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(\n  power,\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  minResolution = minResolution !== undefined ? minResolution : 0;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance\n        );\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(\n          Math.log(maxResolution / capped) / Math.log(power) + offset\n        );\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        if (!smooth || !isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(\n          resolution,\n          cappedMaxRes,\n          minResolution\n        );\n      }\n      return undefined;\n    }\n  );\n}\n","/**\n * @module ol/View\n */\nimport BaseObject from './Object.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {\n  METERS_PER_UNIT,\n  createProjection,\n  disableCoordinateWarning,\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from './proj.js';\nimport {VOID} from './functions.js';\nimport {\n  add as addCoordinate,\n  equals as coordinatesEqual,\n  equals,\n  rotate as rotateCoordinate,\n} from './coordinate.js';\nimport {assert} from './asserts.js';\nimport {none as centerNone, createExtent} from './centerconstraint.js';\nimport {clamp, modulo} from './math.js';\nimport {\n  createMinMaxResolution,\n  createSnapToPower,\n  createSnapToResolutions,\n} from './resolutionconstraint.js';\nimport {\n  createSnapToN,\n  createSnapToZero,\n  disable,\n  none as rotationNone,\n} from './rotationconstraint.js';\nimport {easeOut, inAndOut} from './easing.js';\nimport {\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n  isEmpty,\n} from './extent.js';\nimport {linearFindNearest} from './array.js';\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\n\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\n * @property {number} [sourceResolution] Source resolution.\n * @property {number} [targetResolution] Target resolution.\n * @property {number} [sourceRotation] Source rotation.\n * @property {number} [targetRotation] Target rotation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\n * @property {number} start Start.\n * @property {number} duration Duration.\n * @property {boolean} complete Complete.\n * @property {function(number):number} easing Easing.\n * @property {function(boolean):void} callback Callback.\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {import(\"./centerconstraint.js\").Type} center Center.\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\n * get the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean):void} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n * the view. If a user projection is not set, the coordinate system for the center is\n * specified with the `projection` option. Layer sources will not be fetched if this\n * is not set, but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n * view, in other words, nothing outside of this extent can be visible on the map.\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\n * constraint will only apply to the view center and not the whole extent.\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\n * of the given `extent`.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\n * global.  Note that if `extent` is also provided it is given precedence.\n * @property {boolean} [constrainResolution=false] If true, the view will always\n * animate to the closest zoom level after an interaction; false means\n * intermediary zoom levels are allowed.\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\n * the given resolution or zoom bounds.\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\n * show the full configured extent. By default, when a view is configured with an\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\n * either dimension. This means the full extent may not be visible if the viewport\n * is taller or wider than the aspect ratio of the configured extent. If\n * showFullExtent is true, the user will be able to zoom out so that the viewport\n * exceeds the height or width of the configured extent, but not both, allowing the\n * full extent to be shown.\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions that determine the\n * zoom levels if specified. The index in the array corresponds to the zoom level,\n * therefore the resolution values have to be in descending order. It also constrains\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view.\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\n * corresponding resolution.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\n * If the map viewport is partially covered with other content (overlays) along\n * its edges, this setting allows to shift the center of the viewport away from\n * that content. The order of the values is top, right, bottom, left.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./coordinate.js\").Coordinate} center Center (in view projection coordinates).\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\n * @property {number} resolution Resolution.\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\n * @property {number} [nextResolution] The next resolution during an animation series.\n * @property {number} [nextRotation] The next rotation during an animation series.\n * @property {number} rotation Rotation.\n * @property {number} zoom Zoom.\n */\n\n/**\n * Like {@link import(\"./Map.js\").FrameState}, but just `viewState` and `extent`.\n * @typedef {Object} ViewStateLayerStateExtent\n * @property {State} viewState View state.\n * @property {import(\"./extent.js\").Extent} extent Extent (in user projection coordinates).\n * @property {Array<import(\"./layer/Layer.js\").State>} [layerStatesArray] Layer states.\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\nconst DEFAULT_MIN_ZOOM = 0;\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\n */\n\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * A View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Web Mercator (EPSG:3857).\n *\n * ### The view states\n *\n * A View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * The `zoom` state is actually not saved on the view: all computations\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\n * methods are available, as well as `getResolutionForZoom` and\n * `getZoomForResolution` to switch from one system to the other.\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view, but any constraint defined in the constructor will\n * be applied along the way.\n *\n * A View object can have a *resolution constraint*, a *rotation constraint*\n * and a *center constraint*.\n *\n * The *resolution constraint* typically restricts min/max values and\n * snaps to specific resolutions. It is determined by the following\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\n * If `resolutions` is set, the other three options are ignored. See\n * documentation for each option for more information. By default, the view\n * only has a min/max restriction and allow intermediary zoom levels when\n * pinch-zooming for example.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default rotation is allowed and its value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the view center is not constrained at all.\n *\n * ### Changing the view state\n *\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\n * `setRotation` are subject to the above mentioned constraints. As such, it\n * may sometimes not be possible to know in advance the resulting state of the\n * View. For example, calling `setResolution(10)` does not guarantee that\n * `getResolution()` will return `10`.\n *\n * A consequence of this is that, when applying a delta on the view state, one\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\n * rather than the corresponding setters. This will let view do its internal\n * computations. Besides, the `adjust*` methods also take an `anchor`\n * argument which allows specifying an origin for the transformation.\n *\n * ### Interacting with the view\n *\n * View constraints are usually only applied when the view is *at rest*, meaning that\n * no interaction or animation is ongoing. As such, if the user puts the view in a\n * state that is not equivalent to a constrained one (e.g. rotating the view when\n * the snap angle is 0), an animation will be triggered at the interaction end to\n * put back the view to a stable state;\n *\n * @api\n */\nclass View extends BaseObject {\n  /**\n   * @param {ViewOptions} [options] View options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ViewOnSignature<void>}\n     */\n    this.un;\n\n    options = Object.assign({}, options);\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.hints_ = [0, 0];\n\n    /**\n     * @private\n     * @type {Array<Array<Animation>>}\n     */\n    this.animations_ = [];\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.updateAnimationKey_;\n\n    /**\n     * @private\n     * @const\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n\n    /**\n     * @private\n     * @type {import(\"./size.js\").Size}\n     */\n    this.viewportSize_ = [100, 100];\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.targetCenter_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetResolution_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n    this.nextCenter_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextResolution_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.cancelAnchor_ = undefined;\n\n    if (options.projection) {\n      disableCoordinateWarning();\n    }\n    if (options.center) {\n      options.center = fromUserCoordinate(options.center, this.projection_);\n    }\n    if (options.extent) {\n      options.extent = fromUserExtent(options.extent, this.projection_);\n    }\n\n    this.applyOptions_(options);\n  }\n\n  /**\n   * Set up the view with the given options.\n   * @param {ViewOptions} options View options.\n   */\n  applyOptions_(options) {\n    const properties = Object.assign({}, options);\n    for (const key in ViewProperty) {\n      delete properties[key];\n    }\n    this.setProperties(properties, true);\n\n    const resolutionConstraintInfo = createResolutionConstraint(options);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n\n    /**\n     * @private\n     * @type {Array<number>|undefined}\n     */\n    this.resolutions_ = options.resolutions;\n\n    /**\n     * @type {Array<number>|undefined}\n     * @private\n     */\n    this.padding_ = options.padding;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n\n    const centerConstraint = createCenterConstraint(options);\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\n    const rotationConstraint = createRotationConstraint(options);\n\n    /**\n     * @private\n     * @type {Constraints}\n     */\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint,\n    };\n\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\n    this.setCenterInternal(\n      options.center !== undefined ? options.center : null\n    );\n    if (options.resolution !== undefined) {\n      this.setResolution(options.resolution);\n    } else if (options.zoom !== undefined) {\n      this.setZoom(options.zoom);\n    }\n  }\n\n  /**\n   * Padding (in css pixels).\n   * If the map viewport is partially covered with other content (overlays) along\n   * its edges, this setting allows to shift the center of the viewport away from that\n   * content. The order of the values in the array is top, right, bottom, left.\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\n   * @type {Array<number>|undefined}\n   * @api\n   */\n  get padding() {\n    return this.padding_;\n  }\n  set padding(padding) {\n    let oldPadding = this.padding_;\n    this.padding_ = padding;\n    const center = this.getCenterInternal();\n    if (center) {\n      const newPadding = padding || [0, 0, 0, 0];\n      oldPadding = oldPadding || [0, 0, 0, 0];\n      const resolution = this.getResolution();\n      const offsetX =\n        (resolution / 2) *\n        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n      const offsetY =\n        (resolution / 2) *\n        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n    }\n  }\n\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {ViewOptions} newOptions New options to be applied.\n   * @return {ViewOptions} New options updated with the current view state.\n   */\n  getUpdatedOptions_(newOptions) {\n    const options = this.getProperties();\n\n    // preserve resolution (or zoom)\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n\n    // preserve center\n    options.center = this.getCenterInternal();\n\n    // preserve rotation\n    options.rotation = this.getRotation();\n\n    return Object.assign({}, options, newOptions);\n  }\n\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n  animate(var_args) {\n    if (this.isDef() && !this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n    const args = new Array(arguments.length);\n    for (let i = 0; i < args.length; ++i) {\n      let options = arguments[i];\n      if (options.center) {\n        options = Object.assign({}, options);\n        options.center = fromUserCoordinate(\n          options.center,\n          this.getProjection()\n        );\n      }\n      if (options.anchor) {\n        options = Object.assign({}, options);\n        options.anchor = fromUserCoordinate(\n          options.anchor,\n          this.getProjection()\n        );\n      }\n      args[i] = options;\n    }\n    this.animateInternal.apply(this, args);\n  }\n\n  /**\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\n   */\n  animateInternal(var_args) {\n    let animationCount = arguments.length;\n    let callback;\n    if (\n      animationCount > 1 &&\n      typeof arguments[animationCount - 1] === 'function'\n    ) {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    let i = 0;\n    for (; i < animationCount && !this.isDef(); ++i) {\n      // if view properties are not yet set, shortcut to the final state\n      const state = arguments[i];\n      if (state.center) {\n        this.setCenterInternal(state.center);\n      }\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      } else if (state.resolution) {\n        this.setResolution(state.resolution);\n      }\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n    }\n    if (i === animationCount) {\n      if (callback) {\n        animationCallback(callback, true);\n      }\n      return;\n    }\n\n    let start = Date.now();\n    let center = this.targetCenter_.slice();\n    let resolution = this.targetResolution_;\n    let rotation = this.targetRotation_;\n    const series = [];\n    for (; i < animationCount; ++i) {\n      const options = /** @type {AnimationOptions} */ (arguments[i]);\n\n      const animation = {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut,\n        callback: callback,\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center.slice();\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        const delta =\n          modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      // check if animation is a no-op\n      if (isNoopAnimation(animation)) {\n        animation.complete = true;\n        // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  }\n\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n  getAnimating() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  }\n\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n  getInteracting() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  }\n\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n  cancelAnimations() {\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    let anchor;\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\n      const series = this.animations_[i];\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n      if (!anchor) {\n        for (let j = 0, jj = series.length; j < jj; ++j) {\n          const animation = series[j];\n          if (!animation.complete) {\n            anchor = animation.anchor;\n            break;\n          }\n        }\n      }\n    }\n    this.animations_.length = 0;\n    this.cancelAnchor_ = anchor;\n    this.nextCenter_ = null;\n    this.nextResolution_ = NaN;\n    this.nextRotation_ = NaN;\n  }\n\n  /**\n   * Update all animations.\n   */\n  updateAnimations_() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    const now = Date.now();\n    let more = false;\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\n      const series = this.animations_[i];\n      let seriesComplete = true;\n      for (let j = 0, jj = series.length; j < jj; ++j) {\n        const animation = series[j];\n        if (animation.complete) {\n          continue;\n        }\n        const elapsed = now - animation.start;\n        let fraction =\n          animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        const progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          const x0 = animation.sourceCenter[0];\n          const y0 = animation.sourceCenter[1];\n          const x1 = animation.targetCenter[0];\n          const y1 = animation.targetCenter[1];\n          this.nextCenter_ = animation.targetCenter;\n          const x = x0 + progress * (x1 - x0);\n          const y = y0 + progress * (y1 - y0);\n          this.targetCenter_ = [x, y];\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          const resolution =\n            progress === 1\n              ? animation.targetResolution\n              : animation.sourceResolution +\n                progress *\n                  (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            const size = this.getViewportSize_(this.getRotation());\n            const constrainedResolution = this.constraints_.resolution(\n              resolution,\n              0,\n              size,\n              true\n            );\n            this.targetCenter_ = this.calculateCenterZoom(\n              constrainedResolution,\n              animation.anchor\n            );\n          }\n          this.nextResolution_ = animation.targetResolution;\n          this.targetResolution_ = resolution;\n          this.applyTargetState_(true);\n        }\n        if (\n          animation.sourceRotation !== undefined &&\n          animation.targetRotation !== undefined\n        ) {\n          const rotation =\n            progress === 1\n              ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\n                Math.PI\n              : animation.sourceRotation +\n                progress *\n                  (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            const constrainedRotation = this.constraints_.rotation(\n              rotation,\n              true\n            );\n            this.targetCenter_ = this.calculateCenterRotate(\n              constrainedRotation,\n              animation.anchor\n            );\n          }\n          this.nextRotation_ = animation.targetRotation;\n          this.targetRotation_ = rotation;\n        }\n        this.applyTargetState_(true);\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ViewHint.ANIMATING, -1);\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n        const callback = series[0].callback;\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    }\n    // prune completed series\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(\n        this.updateAnimations_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n   */\n  calculateCenterRotate(rotation, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n    return center;\n  }\n\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n   */\n  calculateCenterZoom(resolution, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    const currentResolution = this.getResolution();\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      const x =\n        anchor[0] -\n        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\n      const y =\n        anchor[1] -\n        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\n      center = [x, y];\n    }\n    return center;\n  }\n\n  /**\n   * Returns the current viewport size.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n  getViewportSize_(rotation) {\n    const size = this.viewportSize_;\n    if (rotation) {\n      const w = size[0];\n      const h = size[1];\n      return [\n        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),\n        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\n   * to avoid performance hit and layout reflow.\n   * This should be done on map size change.\n   * Note: the constraints are not resolved during an animation to avoid stopping it\n   * @param {import(\"./size.js\").Size} [size] Viewport size; if undefined, [100, 100] is assumed\n   */\n  setViewportSize(size) {\n    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];\n    if (!this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n  }\n\n  /**\n   * Get the view center.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n  getCenter() {\n    const center = this.getCenterInternal();\n    if (!center) {\n      return center;\n    }\n    return toUserCoordinate(center, this.getProjection());\n  }\n\n  /**\n   * Get the view center without transforming to user projection.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   */\n  getCenterInternal() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(ViewProperty.CENTER)\n    );\n  }\n\n  /**\n   * @return {Constraints} Constraints.\n   */\n  getConstraints() {\n    return this.constraints_;\n  }\n\n  /**\n   * @return {boolean} Resolution constraint is set\n   */\n  getConstrainResolution() {\n    return this.get('constrainResolution');\n  }\n\n  /**\n   * @param {Array<number>} [hints] Destination array.\n   * @return {Array<number>} Hint.\n   */\n  getHints(hints) {\n    if (hints !== undefined) {\n      hints[0] = this.hints_[0];\n      hints[1] = this.hints_[1];\n      return hints;\n    }\n    return this.hints_.slice();\n  }\n\n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided, the size\n   * of the map that uses this view will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   * @api\n   */\n  calculateExtent(size) {\n    const extent = this.calculateExtentInternal(size);\n    return toUserExtent(extent, this.getProjection());\n  }\n\n  /**\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided,\n   * the map's last known viewport size will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  calculateExtentInternal(size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    assert(center, 'The view center is not defined');\n    const resolution = /** @type {!number} */ (this.getResolution());\n    assert(resolution !== undefined, 'The view resolution is not defined');\n    const rotation = /** @type {!number} */ (this.getRotation());\n    assert(rotation !== undefined, 'The view rotation is not defined');\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  }\n\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n  getMaxResolution() {\n    return this.maxResolution_;\n  }\n\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n  getMinResolution() {\n    return this.minResolution_;\n  }\n\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.minResolution_)\n    );\n  }\n\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n  setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\n  }\n\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  }\n\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n  setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\n  }\n\n  /**\n   * Set whether the view should allow intermediary zoom levels.\n   * @param {boolean} enabled Whether the resolution is constrained.\n   * @api\n   */\n  setConstrainResolution(enabled) {\n    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));\n  }\n\n  /**\n   * Get the view projection.\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n   * @api\n   */\n  getProjection() {\n    return this.projection_;\n  }\n\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n  getResolution() {\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\n  }\n\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array<number>|undefined} The resolutions of the view.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n  getResolutionForExtent(extent, size) {\n    return this.getResolutionForExtentInternal(\n      fromUserExtent(extent, this.getProjection()),\n      size\n    );\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   */\n  getResolutionForExtentInternal(extent, size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const xResolution = getWidth(extent) / size[0];\n    const yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  }\n\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n  getResolutionForValueFunction(power) {\n    power = power || 2;\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        const resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  }\n\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  getRotation() {\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\n  }\n\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n  getValueForResolutionFunction(power) {\n    const logPower = Math.log(power || 2);\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / logPower;\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        const value = Math.log(maxResolution / resolution) / logPower / max;\n        return value;\n      }\n    );\n  }\n\n  /**\n   * Returns the size of the viewport minus padding.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\n   */\n  getViewportSizeMinusPadding_(rotation) {\n    let size = this.getViewportSize_(rotation);\n    const padding = this.padding_;\n    if (padding) {\n      size = [\n        size[0] - padding[1] - padding[3],\n        size[1] - padding[0] - padding[2],\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * @return {State} View state.\n   */\n  getState() {\n    const projection = this.getProjection();\n    const resolution = this.getResolution();\n    const rotation = this.getRotation();\n    let center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    const padding = this.padding_;\n    if (padding) {\n      const reducedSize = this.getViewportSizeMinusPadding_();\n      center = calculateCenterOn(\n        center,\n        this.getViewportSize_(),\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation\n      );\n    }\n    return {\n      center: center.slice(0),\n      projection: projection !== undefined ? projection : null,\n      resolution: resolution,\n      nextCenter: this.nextCenter_,\n      nextResolution: this.nextResolution_,\n      nextRotation: this.nextRotation_,\n      rotation: rotation,\n      zoom: this.getZoom(),\n    };\n  }\n\n  /**\n   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.\n   */\n  getViewStateAndExtent() {\n    return {\n      viewState: this.getState(),\n      extent: this.calculateExtent(),\n    };\n  }\n\n  /**\n   * Get the current zoom level. This method may return non-integer zoom levels\n   * if the view does not constrain the resolution, or if an interaction or\n   * animation is underway.\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n  getZoom() {\n    let zoom;\n    const resolution = this.getResolution();\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  }\n\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n  getZoomForResolution(resolution) {\n    let offset = this.minZoom_ || 0;\n    let max, zoomFactor;\n    if (this.resolutions_) {\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  }\n\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n  getResolutionForZoom(zoom) {\n    if (this.resolutions_) {\n      if (this.resolutions_.length <= 1) {\n        return 0;\n      }\n      const baseLevel = clamp(\n        Math.floor(zoom),\n        0,\n        this.resolutions_.length - 2\n      );\n      const zoomFactor =\n        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n      return (\n        this.resolutions_[baseLevel] /\n        Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1))\n      );\n    }\n    return (\n      this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)\n    );\n  }\n\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {FitOptions} [options] Options.\n   * @api\n   */\n  fit(geometryOrExtent, options) {\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n    let geometry;\n    assert(\n      Array.isArray(geometryOrExtent) ||\n        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===\n          'function',\n      'Invalid extent or geometry provided as `geometry`'\n    );\n    if (Array.isArray(geometryOrExtent)) {\n      assert(\n        !isEmpty(geometryOrExtent),\n        'Cannot fit empty extent provided as `geometry`'\n      );\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\n      geometry = polygonFromExtent(extent);\n    } else if (geometryOrExtent.getType() === 'Circle') {\n      const extent = fromUserExtent(\n        geometryOrExtent.getExtent(),\n        this.getProjection()\n      );\n      geometry = polygonFromExtent(extent);\n      geometry.rotate(this.getRotation(), getCenter(extent));\n    } else {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n          geometryOrExtent\n            .clone()\n            .transform(userProjection, this.getProjection())\n        );\n      } else {\n        geometry = geometryOrExtent;\n      }\n    }\n\n    this.fitInternal(geometry, options);\n  }\n\n  /**\n   * Calculate rotated extent\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\n   */\n  rotatedExtentForGeometry(geometry) {\n    const rotation = this.getRotation();\n    const cosAngle = Math.cos(rotation);\n    const sinAngle = Math.sin(-rotation);\n    const coords = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    let minRotX = +Infinity;\n    let minRotY = +Infinity;\n    let maxRotX = -Infinity;\n    let maxRotY = -Infinity;\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n    return [minRotX, minRotY, maxRotX, maxRotY];\n  }\n\n  /**\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @param {FitOptions} [options] Options.\n   */\n  fitInternal(geometry, options) {\n    options = options || {};\n    let size = options.size;\n    if (!size) {\n      size = this.getViewportSizeMinusPadding_();\n    }\n    const padding =\n      options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    const nearest = options.nearest !== undefined ? options.nearest : false;\n    let minResolution;\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.getResolutionForZoom(options.maxZoom);\n    } else {\n      minResolution = 0;\n    }\n\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry);\n\n    // calculate resolution\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [\n      size[0] - padding[1] - padding[3],\n      size[1] - padding[0] - padding[2],\n    ]);\n    resolution = isNaN(resolution)\n      ? minResolution\n      : Math.max(resolution, minResolution);\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\n\n    // calculate center\n    const rotation = this.getRotation();\n    const sinAngle = Math.sin(rotation);\n    const cosAngle = Math.cos(rotation);\n    const centerRot = getCenter(rotatedExtent);\n    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\n    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\n    const callback = options.callback ? options.callback : VOID;\n\n    if (options.duration !== undefined) {\n      this.animateInternal(\n        {\n          resolution: resolution,\n          center: center,\n          duration: options.duration,\n          easing: options.easing,\n        },\n        callback\n      );\n    } else {\n      this.targetResolution_ = resolution;\n      this.targetCenter_ = center;\n      this.applyTargetState_(false, true);\n      animationCallback(callback, true);\n    }\n  }\n\n  /**\n   * Center on coordinate and view position.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   * @api\n   */\n  centerOn(coordinate, size, position) {\n    this.centerOnInternal(\n      fromUserCoordinate(coordinate, this.getProjection()),\n      size,\n      position\n    );\n  }\n\n  /**\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   */\n  centerOnInternal(coordinate, size, position) {\n    this.setCenterInternal(\n      calculateCenterOn(\n        coordinate,\n        size,\n        position,\n        this.getResolution(),\n        this.getRotation()\n      )\n    );\n  }\n\n  /**\n   * Calculates the shift between map and viewport center.\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {import(\"./size.js\").Size} size Size.\n   * @return {Array<number>|undefined} Center shift.\n   */\n  calculateCenterShift(center, resolution, rotation, size) {\n    let centerShift;\n    const padding = this.padding_;\n    if (padding && center) {\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n      const shiftedCenter = calculateCenterOn(\n        center,\n        size,\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation\n      );\n      centerShift = [\n        center[0] - shiftedCenter[0],\n        center[1] - shiftedCenter[1],\n      ];\n    }\n    return centerShift;\n  }\n\n  /**\n   * @return {boolean} Is defined.\n   */\n  isDef() {\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   * @api\n   */\n  adjustCenter(deltaCoordinates) {\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\n    this.setCenter([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   */\n  adjustCenterInternal(deltaCoordinates) {\n    const center = this.targetCenter_;\n    this.setCenterInternal([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustResolution(ratio, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.adjustResolutionInternal(ratio, anchor);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  adjustResolutionInternal(ratio, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const size = this.getViewportSize_(this.getRotation());\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_ * ratio,\n      0,\n      size,\n      isMoving\n    );\n\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);\n    }\n\n    this.targetResolution_ *= ratio;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom level.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustZoom(delta, anchor) {\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);\n  }\n\n  /**\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   * @api\n   */\n  adjustRotation(delta, anchor) {\n    if (anchor) {\n      anchor = fromUserCoordinate(anchor, this.getProjection());\n    }\n    this.adjustRotationInternal(delta, anchor);\n  }\n\n  /**\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   */\n  adjustRotationInternal(delta, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_ + delta,\n      isMoving\n    );\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);\n    }\n    this.targetRotation_ += delta;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the center of the current view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n  setCenter(center) {\n    this.setCenterInternal(\n      center ? fromUserCoordinate(center, this.getProjection()) : center\n    );\n  }\n\n  /**\n   * Set the center using the view projection (not the user projection).\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   */\n  setCenterInternal(center) {\n    this.targetCenter_ = center;\n    this.applyTargetState_();\n  }\n\n  /**\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n  setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  }\n\n  /**\n   * Set the resolution for this view. Any resolution constraint will apply.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n  setResolution(resolution) {\n    this.targetResolution_ = resolution;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the rotation for this view. Any rotation constraint will apply.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  setRotation(rotation) {\n    this.targetRotation_ = rotation;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n  setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  }\n\n  /**\n   * Recompute rotation/resolution/center based on target values.\n   * Note: we have to compute rotation first, then resolution and center considering that\n   * parameters can influence one another in case a view extent constraint is present.\n   * @param {boolean} [doNotCancelAnims] Do not cancel animations.\n   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.\n   * @private\n   */\n  applyTargetState_(doNotCancelAnims, forceMoving) {\n    const isMoving =\n      this.getAnimating() || this.getInteracting() || forceMoving;\n\n    // compute rotation\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_,\n      isMoving\n    );\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      0,\n      size,\n      isMoving\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      isMoving,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size\n      )\n    );\n\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\n      this.set(ViewProperty.ROTATION, newRotation);\n    }\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n      this.set(ViewProperty.RESOLUTION, newResolution);\n      this.set('zoom', this.getZoom(), true);\n    }\n    if (\n      !newCenter ||\n      !this.get(ViewProperty.CENTER) ||\n      !equals(this.get(ViewProperty.CENTER), newCenter)\n    ) {\n      this.set(ViewProperty.CENTER, newCenter);\n    }\n\n    if (this.getAnimating() && !doNotCancelAnims) {\n      this.cancelAnimations();\n    }\n    this.cancelAnchor_ = undefined;\n  }\n\n  /**\n   * If any constraints need to be applied, an animation will be triggered.\n   * This is typically done on interaction end.\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\n   * without animation.\n   * @param {number} [duration] The animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  resolveConstraints(duration, resolutionDirection, anchor) {\n    duration = duration !== undefined ? duration : 200;\n    const direction = resolutionDirection || 0;\n\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      direction,\n      size\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      false,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size\n      )\n    );\n\n    if (duration === 0 && !this.cancelAnchor_) {\n      this.targetResolution_ = newResolution;\n      this.targetRotation_ = newRotation;\n      this.targetCenter_ = newCenter;\n      this.applyTargetState_();\n      return;\n    }\n\n    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\n    this.cancelAnchor_ = undefined;\n\n    if (\n      this.getResolution() !== newResolution ||\n      this.getRotation() !== newRotation ||\n      !this.getCenterInternal() ||\n      !equals(this.getCenterInternal(), newCenter)\n    ) {\n      if (this.getAnimating()) {\n        this.cancelAnimations();\n      }\n\n      this.animateInternal({\n        rotation: newRotation,\n        center: newCenter,\n        resolution: newResolution,\n        duration: duration,\n        easing: easeOut,\n        anchor: anchor,\n      });\n    }\n  }\n\n  /**\n   * Notify the View that an interaction has started.\n   * The view state will be resolved to a stable one if needed\n   * (depending on its constraints).\n   * @api\n   */\n  beginInteraction() {\n    this.resolveConstraints(0);\n\n    this.setHint(ViewHint.INTERACTING, 1);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  endInteraction(duration, resolutionDirection, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.endInteractionInternal(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  endInteractionInternal(duration, resolutionDirection, anchor) {\n    if (!this.getInteracting()) {\n      return;\n    }\n    this.setHint(ViewHint.INTERACTING, -1);\n    this.resolveConstraints(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Get a valid position for the view center according to the current constraints.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\n   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.\n   * This is useful to guess a valid center position at a different zoom level.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\n   */\n  getConstrainedCenter(targetCenter, targetResolution) {\n    const size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.center(\n      targetCenter,\n      targetResolution || this.getResolution(),\n      size\n    );\n  }\n\n  /**\n   * Get a valid zoom level according to the current view constraints.\n   * @param {number|undefined} targetZoom Target zoom.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid zoom level.\n   */\n  getConstrainedZoom(targetZoom, direction) {\n    const targetRes = this.getResolutionForZoom(targetZoom);\n    return this.getZoomForResolution(\n      this.getConstrainedResolution(targetRes, direction)\n    );\n  }\n\n  /**\n   * Get a valid resolution according to the current view constraints.\n   * @param {number|undefined} targetResolution Target resolution.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid resolution.\n   */\n  getConstrainedResolution(targetResolution, direction) {\n    direction = direction || 0;\n    const size = this.getViewportSize_(this.getRotation());\n\n    return this.constraints_.resolution(targetResolution, direction, size);\n  }\n}\n\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function () {\n    callback(returnValue);\n  }, 0);\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\n */\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    const smooth =\n      options.smoothExtentConstraint !== undefined\n        ? options.smoothExtentConstraint\n        : true;\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n  }\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  if (options.multiWorld !== true && projection.isGlobal()) {\n    const extent = projection.getExtent().slice();\n    extent[0] = -Infinity;\n    extent[2] = Infinity;\n    return createExtent(extent, false, false);\n  }\n\n  return centerNone;\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\nexport function createResolutionConstraint(options) {\n  let resolutionConstraint;\n  let maxResolution;\n  let minResolution;\n\n  // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n  const defaultMaxZoom = 28;\n  const defaultZoomFactor = 2;\n\n  let minZoom =\n    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n\n  let maxZoom =\n    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n\n  const zoomFactor =\n    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n  const multiWorld =\n    options.multiWorld !== undefined ? options.multiWorld : false;\n\n  const smooth =\n    options.smoothResolutionConstraint !== undefined\n      ? options.smoothResolutionConstraint\n      : true;\n\n  const showFullExtent =\n    options.showFullExtent !== undefined ? options.showFullExtent : false;\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  const projExtent = projection.getExtent();\n  let constrainOnlyCenter = options.constrainOnlyCenter;\n  let extent = options.extent;\n  if (!multiWorld && !extent && projection.isGlobal()) {\n    constrainOnlyCenter = false;\n    extent = projExtent;\n  }\n\n  if (options.resolutions !== undefined) {\n    const resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution =\n      resolutions[maxZoom] !== undefined\n        ? resolutions[maxZoom]\n        : resolutions[resolutions.length - 1];\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToResolutions(\n        resolutions,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    }\n  } else {\n    // calculate the default min and max resolution\n    const size = !projExtent\n      ? // use an extent that can fit the whole world if need be\n        (360 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()\n      : Math.max(getWidth(projExtent), getHeight(projExtent));\n\n    const defaultMaxResolution =\n      size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n\n    const defaultMinResolution =\n      defaultMaxResolution /\n      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n\n    // user provided maxResolution takes precedence\n    maxResolution = options.maxResolution;\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    }\n\n    // user provided minResolution takes precedence\n    minResolution = options.minResolution;\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    }\n\n    // given discrete zoom levels, minResolution may be different than provided\n    maxZoom =\n      minZoom +\n      Math.floor(\n        Math.log(maxResolution / minResolution) / Math.log(zoomFactor)\n      );\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToPower(\n        zoomFactor,\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    }\n  }\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor,\n  };\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n */\nexport function createRotationConstraint(options) {\n  const enableRotation =\n    options.enableRotation !== undefined ? options.enableRotation : true;\n  if (enableRotation) {\n    const constrainRotation = options.constrainRotation;\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    }\n    if (constrainRotation === false) {\n      return rotationNone;\n    }\n    if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    }\n    return rotationNone;\n  }\n  return disable;\n}\n\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {import(\"./size.js\").Size} size Box pixel size.\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\n */\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\n  // calculate rotated position\n  const cosAngle = Math.cos(-rotation);\n  let sinAngle = Math.sin(-rotation);\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  rotX += (size[0] / 2 - position[0]) * resolution;\n  rotY += (position[1] - size[1] / 2) * resolution;\n\n  // go back to original angle\n  sinAngle = -sinAngle; // go back to original rotation\n  const centerX = rotX * cosAngle - rotY * sinAngle;\n  const centerY = rotY * cosAngle + rotX * sinAngle;\n\n  return [centerX, centerY];\n}\n\nexport default View;\n","/**\n * @module ol/ViewHint\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  ANIMATING: 0,\n  INTERACTING: 1,\n};\n","/**\n * @module ol/array\n */\n\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function} [comparator] Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\nexport function binarySearch(haystack, needle, comparator) {\n  let mid, cmp;\n  comparator = comparator || ascending;\n  let low = 0;\n  let high = haystack.length;\n  let found = false;\n\n  while (low < high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + ((high - low) >> 1);\n    cmp = +comparator(haystack[mid], needle);\n\n    if (cmp < 0.0) {\n      /* Too low. */\n      low = mid + 1;\n    } else {\n      /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n\n  /* Key not found. */\n  return found ? low : ~low;\n}\n\n/**\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nexport function ascending(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n/**\n * Compare function sorting arrays in descending order.  Safe to use for numeric values.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is greater than, equal to, or less than the second.\n */\nexport function descending(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\n/**\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\n * of this type to determine which nearest resolution to use.\n *\n * This function takes a `{number}` representing a value between two array entries,\n * a `{number}` representing the value of the nearest higher entry and\n * a `{number}` representing the value of the nearest lower entry\n * as arguments and returns a `{number}`. If a negative number or zero is returned\n * the lower value will be used, if a positive number is returned the higher value\n * will be used.\n * @typedef {function(number, number, number): number} NearestDirectionFunction\n * @api\n */\n\n/**\n * @param {Array<number>} arr Array in descending order.\n * @param {number} target Target.\n * @param {number|NearestDirectionFunction} direction\n *    0 means return the nearest,\n *    > 0 means return the largest nearest,\n *    < 0 means return the smallest nearest.\n * @return {number} Index.\n */\nexport function linearFindNearest(arr, target, direction) {\n  if (arr[0] <= target) {\n    return 0;\n  }\n\n  const n = arr.length;\n  if (target <= arr[n - 1]) {\n    return n - 1;\n  }\n\n  if (typeof direction === 'function') {\n    for (let i = 1; i < n; ++i) {\n      const candidate = arr[i];\n      if (candidate === target) {\n        return i;\n      }\n      if (candidate < target) {\n        if (direction(target, arr[i - 1], candidate) > 0) {\n          return i - 1;\n        }\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  if (direction > 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] < target) {\n        return i - 1;\n      }\n    }\n    return n - 1;\n  }\n\n  if (direction < 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] <= target) {\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  for (let i = 1; i < n; ++i) {\n    if (arr[i] == target) {\n      return i;\n    }\n    if (arr[i] < target) {\n      if (arr[i - 1] - target < target - arr[i]) {\n        return i - 1;\n      }\n      return i;\n    }\n  }\n  return n - 1;\n}\n\n/**\n * @param {Array<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\nexport function reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    const tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n * @template VALUE\n */\nexport function extend(arr, data) {\n  const extension = Array.isArray(data) ? data : [data];\n  const length = extension.length;\n  for (let i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\nexport function remove(arr, obj) {\n  const i = arr.indexOf(obj);\n  const found = i > -1;\n  if (found) {\n    arr.splice(i, 1);\n  }\n  return found;\n}\n\n/**\n * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\nexport function equals(arr1, arr2) {\n  const len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort the passed array such that the relative order of equal elements is preserved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n * @api\n */\nexport function stableSort(arr, compareFnc) {\n  const length = arr.length;\n  const tmp = Array(arr.length);\n  let i;\n  for (i = 0; i < length; i++) {\n    tmp[i] = {index: i, value: arr[i]};\n  }\n  tmp.sort(function (a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n}\n\n/**\n * @param {Array<*>} arr The array to test.\n * @param {Function} [func] Comparison function.\n * @param {boolean} [strict] Strictly sorted (default false).\n * @return {boolean} Return index.\n */\nexport function isSorted(arr, func, strict) {\n  const compare = func || ascending;\n  return arr.every(function (currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n    const res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || (strict && res === 0));\n  });\n}\n","/**\n * @module ol/asserts\n */\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {string} errorMessage Error message.\n */\nexport function assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\n","/**\n * @module ol/color\n */\nimport {clamp} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nconst HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nconst NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n  const el = document.createElement('div');\n  el.style.color = color;\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    const rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  }\n  return '';\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport const fromString = (function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  const MAX_CACHE_SIZE = 1024;\n\n  /**\n   * @type {Object<string, Color>}\n   */\n  const cache = {};\n\n  /**\n   * @type {number}\n   */\n  let cacheSize = 0;\n\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      let color;\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          let i = 0;\n          for (const key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n      return color;\n    }\n  );\n})();\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n  let r, g, b, a, color;\n\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    const n = s.length - 1; // number of hex digits\n    let d; // number of digits per channel\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n    const hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n    color = [r, g, b, a / 255];\n  } else if (s.startsWith('rgba(')) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.startsWith('rgb(')) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    throw new Error('Invalid color');\n  }\n  return color;\n}\n\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  if (NAMED_COLOR_RE_.test(s)) {\n    s = fromNamed(s);\n  }\n  return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');\n}\n","/**\n * @module ol/console\n */\n\n/**\n * @typedef {'info'|'warn'|'error'|'none'} Level\n */\n\n/**\n * @type {Object<Level, number>}\n */\nconst levels = {\n  info: 1,\n  warn: 2,\n  error: 3,\n  none: 4,\n};\n\n/**\n * @type {number}\n */\nlet level = levels.info;\n\n/**\n * Set the logging level.  By default, the level is set to 'info' and all\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\n *\n * @param {Level} l The new level.\n */\nexport function setLevel(l) {\n  level = levels[l];\n}\n\nexport function log(...args) {\n  if (level > levels.info) {\n    return;\n  }\n  console.log(...args); // eslint-disable-line no-console\n}\n\nexport function warn(...args) {\n  if (level > levels.warn) {\n    return;\n  }\n  console.warn(...args); // eslint-disable-line no-console\n}\n\nexport function error(...args) {\n  if (level > levels.error) {\n    return;\n  }\n  console.error(...args); // eslint-disable-line no-console\n}\n","/**\n * @module ol/coordinate\n */\nimport {getWidth} from './extent.js';\nimport {modulo, toFixed} from './math.js';\nimport {padNumber} from './string.js';\n\n/**\n * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.\n * Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n  coordinate[0] += +delta[0];\n  coordinate[1] += +delta[1];\n  return coordinate;\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n  const r = circle.getRadius();\n  const center = circle.getCenter();\n  const x0 = center[0];\n  const y0 = center[1];\n  const x1 = coordinate[0];\n  const y1 = coordinate[1];\n\n  let dx = x1 - x0;\n  const dy = y1 - y0;\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const x = x0 + (r * dx) / d;\n  const y = y0 + (r * dy) / d;\n\n  return [x, y];\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n  const x0 = coordinate[0];\n  const y0 = coordinate[1];\n  const start = segment[0];\n  const end = segment[1];\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const along =\n    dx === 0 && dy === 0\n      ? 0\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  let x, y;\n  if (along <= 0) {\n    x = x1;\n    y = y1;\n  } else if (along >= 1) {\n    x = x2;\n    y = y2;\n  } else {\n    x = x1 + along * dx;\n    y = y1 + along * dy;\n  }\n  return [x, y];\n}\n\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY();\n *     const out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY(2);\n *     const out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(fractionDigits) {\n  return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n      return toStringXY(coordinate, fractionDigits);\n    }\n  );\n}\n\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\n  const x = Math.abs(3600 * normalizedDegrees);\n  const decimals = fractionDigits || 0;\n\n  let deg = Math.floor(x / 3600);\n  let min = Math.floor((x - deg * 3600) / 60);\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\n\n  if (sec >= 60) {\n    sec = 0;\n    min += 1;\n  }\n\n  if (min >= 60) {\n    min = 0;\n    deg += 1;\n  }\n\n  let hdms = deg + '\\u00b0';\n  if (min !== 0 || sec !== 0) {\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\n  }\n  if (sec !== 0) {\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\n  }\n  if (normalizedDegrees !== 0) {\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\n  }\n\n  return hdms;\n}\n\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, fractionDigits) {\n  if (coordinate) {\n    return template\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\n  }\n  return '';\n}\n\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n  let equals = true;\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\n    if (coordinate1[i] != coordinate2[i]) {\n      equals = false;\n      break;\n    }\n  }\n  return equals;\n}\n\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x;\n  coordinate[1] = y;\n  return coordinate;\n}\n\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n  coordinate[0] *= scale;\n  coordinate[1] *= scale;\n  return coordinate;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n  const dx = coord1[0] - coord2[0];\n  const dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\n\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord);\n *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord, 1);\n *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, fractionDigits) {\n  if (coordinate) {\n    return (\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\n      ' ' +\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\n    );\n  }\n  return '';\n}\n\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, fractionDigits) {\n  return format(coordinate, '{x}, {y}', fractionDigits);\n}\n\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n  if (projection.canWrapX()) {\n    const worldWidth = getWidth(projection.getExtent());\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n    if (worldsAway) {\n      coordinate[0] -= worldsAway * worldWidth;\n    }\n  }\n  return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number} [sourceExtentWidth] Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\n  const projectionExtent = projection.getExtent();\n  let worldsAway = 0;\n  if (\n    projection.canWrapX() &&\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\n  ) {\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\n    worldsAway = Math.floor(\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth\n    );\n  }\n  return worldsAway;\n}\n","import {WORKER_OFFSCREEN_CANVAS} from './has.js';\n\n/**\n * @module ol/dom\n */\n\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {CanvasRenderingContext2D} */ (\n    canvas.getContext('2d', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\nexport function releaseCanvas(context) {\n  const canvas = context.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  context.clearRect(0, 0, 1, 1);\n}\n\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n  let width = element.offsetWidth;\n  const style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n\n  return width;\n}\n\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n  let height = element.offsetHeight;\n  const style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n\n  return height;\n}\n\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n  const parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n  const oldChildren = node.childNodes;\n\n  for (let i = 0; true; ++i) {\n    const oldChild = oldChildren[i];\n    const newChild = children[i];\n\n    // check if our work is done\n    if (!oldChild && !newChild) {\n      break;\n    }\n\n    // check if children match\n    if (oldChild === newChild) {\n      continue;\n    }\n\n    // check if a new child needs to be added\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    }\n\n    // check if an old child needs to be removed\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    }\n\n    // reorder\n    node.insertBefore(newChild, oldChild);\n  }\n}\n","/**\n * @module ol/easing\n */\n\n/**\n * Start slow and speed up.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function easeIn(t) {\n  return Math.pow(t, 3);\n}\n\n/**\n * Start fast and slow down.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function easeOut(t) {\n  return 1 - easeIn(1 - t);\n}\n\n/**\n * Start slow, speed up, and then slow down again.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function inAndOut(t) {\n  return 3 * t * t - 2 * t * t * t;\n}\n\n/**\n * Maintain a constant speed over time.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function linear(t) {\n  return t;\n}\n\n/**\n * Start slow, speed up, and at the very end slow down again.  This has the\n * same general behavior as {@link module:ol/easing.inAndOut}, but the final\n * slowdown is delayed.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function upAndDown(t) {\n  if (t < 0.5) {\n    return inAndOut(2 * t);\n  }\n  return 1 - inAndOut(2 * (t - 0.5));\n}\n","/**\n * @module ol/events\n */\nimport {clear} from './obj.js';\n\n/**\n * Key to use with {@link module:ol/Observable.unByKey}.\n * @typedef {Object} EventsKey\n * @property {ListenerFunction} listener Listener.\n * @property {import(\"./events/Target.js\").EventTargetLike} target Target.\n * @property {string} type Type.\n * @api\n */\n\n/**\n * Listener function. This function is called with an event object as argument.\n * When the function returns `false`, event propagation will stop.\n *\n * @typedef {function((Event|import(\"./events/Event.js\").default)): (void|boolean)} ListenerFunction\n * @api\n */\n\n/**\n * @typedef {Object} ListenerObject\n * @property {ListenerFunction} handleEvent HandleEvent listener function.\n */\n\n/**\n * @typedef {ListenerFunction|ListenerObject} Listener\n */\n\n/**\n * Registers an event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` to a `this` object, and returns\n * a key for use with {@link module:ol/events.unlistenByKey}.\n *\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @param {boolean} [once] If true, add the listener as one-off listener.\n * @return {EventsKey} Unique key for the listener.\n */\nexport function listen(target, type, listener, thisArg, once) {\n  if (thisArg && thisArg !== target) {\n    listener = listener.bind(thisArg);\n  }\n  if (once) {\n    const originalListener = listener;\n    listener = function () {\n      target.removeEventListener(type, listener);\n      originalListener.apply(this, arguments);\n    };\n  }\n  const eventsKey = {\n    target: target,\n    type: type,\n    listener: listener,\n  };\n  target.addEventListener(type, listener);\n  return eventsKey;\n}\n\n/**\n * Registers a one-off event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` as self-unregistering listener\n * to a `this` object, and returns a key for use with\n * {@link module:ol/events.unlistenByKey} in case the listener needs to be\n * unregistered before it is called.\n *\n * When {@link module:ol/events.listen} is called with the same arguments after this\n * function, the self-unregistering listener will be turned into a permanent\n * listener.\n *\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @return {EventsKey} Key for unlistenByKey.\n */\nexport function listenOnce(target, type, listener, thisArg) {\n  return listen(target, type, listener, thisArg, true);\n}\n\n/**\n * Unregisters event listeners on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * The argument passed to this function is the key returned from\n * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.\n *\n * @param {EventsKey} key The key.\n */\nexport function unlistenByKey(key) {\n  if (key && key.target) {\n    key.target.removeEventListener(key.type, key.listener);\n    clear(key);\n  }\n}\n","/**\n * @module ol/events/Event\n */\n\n/**\n * @classdesc\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\n * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\n *\n * This implementation only provides `type` and `target` properties, and\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\n * for higher level events defined in the library, and works with\n * {@link module:ol/events/Target~Target}.\n */\nclass BaseEvent {\n  /**\n   * @param {string} type Type.\n   */\n  constructor(type) {\n    /**\n     * @type {boolean}\n     */\n    this.propagationStopped;\n\n    /**\n     * @type {boolean}\n     */\n    this.defaultPrevented;\n\n    /**\n     * The event type.\n     * @type {string}\n     * @api\n     */\n    this.type = type;\n\n    /**\n     * The event target.\n     * @type {Object}\n     * @api\n     */\n    this.target = null;\n  }\n\n  /**\n   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events\n   * will be fired.\n   * @api\n   */\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n\n  /**\n   * Stop event propagation.\n   * @api\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function stopPropagation(evt) {\n  evt.stopPropagation();\n}\n\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function preventDefault(evt) {\n  evt.preventDefault();\n}\n\nexport default BaseEvent;\n","/**\n * @module ol/events/EventType\n */\n\n/**\n * @enum {string}\n * @const\n */\nexport default {\n  /**\n   * Generic change event. Triggered when the revision counter is increased.\n   * @event module:ol/events/Event~BaseEvent#change\n   * @api\n   */\n  CHANGE: 'change',\n\n  /**\n   * Generic error event. Triggered when an error occurs.\n   * @event module:ol/events/Event~BaseEvent#error\n   * @api\n   */\n  ERROR: 'error',\n\n  BLUR: 'blur',\n  CLEAR: 'clear',\n  CONTEXTMENU: 'contextmenu',\n  CLICK: 'click',\n  DBLCLICK: 'dblclick',\n  DRAGENTER: 'dragenter',\n  DRAGOVER: 'dragover',\n  DROP: 'drop',\n  FOCUS: 'focus',\n  KEYDOWN: 'keydown',\n  KEYPRESS: 'keypress',\n  LOAD: 'load',\n  RESIZE: 'resize',\n  TOUCHMOVE: 'touchmove',\n  WHEEL: 'wheel',\n};\n","/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport {VOID} from '../functions.js';\nimport {clear} from '../obj.js';\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nclass Target extends Disposable {\n  /**\n   * @param {*} [target] Default event target for dispatched events.\n   */\n  constructor(target) {\n    super();\n\n    /**\n     * @private\n     * @type {*}\n     */\n    this.eventTarget_ = target;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.pendingRemovals_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.dispatching_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n     */\n    this.listeners_ = null;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  addEventListener(type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n    const listeners = this.listeners_ || (this.listeners_ = {});\n    const listenersForType = listeners[type] || (listeners[type] = []);\n    if (!listenersForType.includes(listener)) {\n      listenersForType.push(listener);\n    }\n  }\n\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n  dispatchEvent(event) {\n    const isString = typeof event === 'string';\n    const type = isString ? event : event.type;\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n\n    const evt = isString ? new Event(event) : /** @type {Event} */ (event);\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\n    const pendingRemovals =\n      this.pendingRemovals_ || (this.pendingRemovals_ = {});\n    if (!(type in dispatching)) {\n      dispatching[type] = 0;\n      pendingRemovals[type] = 0;\n    }\n    ++dispatching[type];\n    let propagate;\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      if ('handleEvent' in listeners[i]) {\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */ (\n          listeners[i]\n        ).handleEvent(evt);\n      } else {\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (\n          listeners[i]\n        ).call(this, evt);\n      }\n      if (propagate === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n    if (--dispatching[type] === 0) {\n      let pr = pendingRemovals[type];\n      delete pendingRemovals[type];\n      while (pr--) {\n        this.removeEventListener(type, VOID);\n      }\n      delete dispatching[type];\n    }\n    return propagate;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.listeners_ && clear(this.listeners_);\n  }\n\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n   */\n  getListeners(type) {\n    return (this.listeners_ && this.listeners_[type]) || undefined;\n  }\n\n  /**\n   * @param {string} [type] Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n  hasListener(type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return type\n      ? type in this.listeners_\n      : Object.keys(this.listeners_).length > 0;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  removeEventListener(type, listener) {\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n          // make listener a no-op, and remove later in #dispatchEvent()\n          listeners[index] = VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index, 1);\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default Target;\n","/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\n\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n  const extent = createEmpty();\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [dest] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, dest) {\n  const minX = Math.min.apply(null, xs);\n  const minY = Math.min.apply(null, ys);\n  const maxX = Math.max.apply(null, xs);\n  const maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\n}\n\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, dest) {\n  if (dest) {\n    dest[0] = extent[0] - value;\n    dest[1] = extent[1] - value;\n    dest[2] = extent[2] + value;\n    dest[3] = extent[3] + value;\n    return dest;\n  }\n  return [\n    extent[0] - value,\n    extent[1] - value,\n    extent[2] + value,\n    extent[3] + value,\n  ];\n}\n\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [dest] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent.slice();\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n  let dx, dy;\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[0] &&\n    extent2[2] <= extent1[2] &&\n    extent1[1] <= extent2[1] &&\n    extent2[3] <= extent1[3]\n  );\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const x = coordinate[0];\n  const y = coordinate[1];\n  let relationship = Relationship.UNKNOWN;\n  if (x < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n  if (y < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n  return relationship;\n}\n\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\n  if (dest) {\n    dest[0] = minX;\n    dest[1] = minY;\n    dest[2] = maxX;\n    dest[3] = maxY;\n    return dest;\n  }\n  return [minX, minY, maxX, maxY];\n}\n\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(dest) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  return createOrUpdate(x, y, x, y, dest);\n}\n\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendCoordinates(extent, coordinates);\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  dest\n) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendRings(extent, rings);\n}\n\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n  return (\n    extent1[0] == extent2[0] &&\n    extent1[2] == extent2[2] &&\n    extent1[1] == extent2[1] &&\n    extent1[3] == extent2[3]\n  );\n}\n\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n  return (\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\n    Math.abs(extent1[3] - extent2[3]) < tolerance\n  );\n}\n\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(\n  extent,\n  flatCoordinates,\n  offset,\n  end,\n  stride\n) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n  let val;\n  val = callback(getBottomLeft(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getBottomRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopLeft(extent));\n  if (val) {\n    return val;\n  }\n  return false;\n}\n\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n  let area = 0;\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n  return area;\n}\n\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n  let coordinate;\n  if (corner === 'bottom-left') {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === 'bottom-right') {\n    coordinate = getBottomRight(extent);\n  } else if (corner === 'top-left') {\n    coordinate = getTopLeft(extent);\n  } else if (corner === 'top-right') {\n    coordinate = getTopRight(extent);\n  } else {\n    throw new Error('Invalid corner');\n  }\n  return coordinate;\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n  const minX = Math.min(extent1[0], extent2[0]);\n  const minY = Math.min(extent1[1], extent2[1]);\n  const maxX = Math.max(extent1[2], extent2[2]);\n  const maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\n    center,\n    resolution,\n    rotation,\n    size\n  );\n  return createOrUpdate(\n    Math.min(x0, x1, x2, x3),\n    Math.min(y0, y1, y2, y3),\n    Math.max(x0, x1, x2, x3),\n    Math.max(y0, y1, y2, y3),\n    dest\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\nexport function getRotatedViewport(center, resolution, rotation, size) {\n  const dx = (resolution * size[0]) / 2;\n  const dy = (resolution * size[1]) / 2;\n  const cosRotation = Math.cos(rotation);\n  const sinRotation = Math.sin(rotation);\n  const xCos = dx * cosRotation;\n  const xSin = dx * sinRotation;\n  const yCos = dy * cosRotation;\n  const ySin = dy * sinRotation;\n  const x = center[0];\n  const y = center[1];\n  return [\n    x - xCos + ySin,\n    y - xSin - yCos,\n    x - xCos - ySin,\n    y - xSin + yCos,\n    x + xCos - ySin,\n    y + xSin + yCos,\n    x + xCos + ySin,\n    y + xSin - yCos,\n    x - xCos + ySin,\n    y - xSin - yCos,\n  ];\n}\n\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n  return extent[3] - extent[1];\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n  const intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [dest] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, dest) {\n  const intersection = dest ? dest : createEmpty();\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n  return intersection;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n  return extent[2] - extent[0];\n}\n\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[2] &&\n    extent1[2] >= extent2[0] &&\n    extent1[1] <= extent2[3] &&\n    extent1[3] >= extent2[1]\n  );\n}\n\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n  let intersects = false;\n  const startRel = coordinateRelationship(extent, start);\n  const endRel = coordinateRelationship(extent, end);\n  if (\n    startRel === Relationship.INTERSECTING ||\n    endRel === Relationship.INTERSECTING\n  ) {\n    intersects = true;\n  } else {\n    const minX = extent[0];\n    const minY = extent[1];\n    const maxX = extent[2];\n    const maxY = extent[3];\n    const startX = start[0];\n    const startY = start[1];\n    const endX = end[0];\n    const endY = end[1];\n    const slope = (endY - startY) / (endX - startX);\n    let x, y;\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.RIGHT) &&\n      !(startRel & Relationship.RIGHT)\n    ) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.BELOW) &&\n      !(startRel & Relationship.BELOW)\n    ) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.LEFT) &&\n      !(startRel & Relationship.LEFT)\n    ) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n  return intersects;\n}\n\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [dest] Destination extent.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, dest, stops) {\n  if (isEmpty(extent)) {\n    return createOrUpdateEmpty(dest);\n  }\n  let coordinates = [];\n  if (stops > 1) {\n    const width = extent[2] - extent[0];\n    const height = extent[3] - extent[1];\n    for (let i = 0; i < stops; ++i) {\n      coordinates.push(\n        extent[0] + (width * i) / stops,\n        extent[1],\n        extent[2],\n        extent[1] + (height * i) / stops,\n        extent[2] - (width * i) / stops,\n        extent[3],\n        extent[0],\n        extent[3] - (height * i) / stops\n      );\n    }\n  } else {\n    coordinates = [\n      extent[0],\n      extent[1],\n      extent[2],\n      extent[1],\n      extent[2],\n      extent[3],\n      extent[0],\n      extent[3],\n    ];\n  }\n  transformFn(coordinates, coordinates, 2);\n  const xs = [];\n  const ys = [];\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\n    xs.push(coordinates[i]);\n    ys.push(coordinates[i + 1]);\n  }\n  return _boundingExtentXYs(xs, ys, dest);\n}\n\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n  const projectionExtent = projection.getExtent();\n  const center = getCenter(extent);\n  if (\n    projection.canWrapX() &&\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\n  ) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.floor(\n      (center[0] - projectionExtent[0]) / worldWidth\n    );\n    const offset = worldsAway * worldWidth;\n    extent[0] -= offset;\n    extent[2] -= offset;\n  }\n  return extent;\n}\n\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */\nexport function wrapAndSliceX(extent, projection) {\n  if (projection.canWrapX()) {\n    const projectionExtent = projection.getExtent();\n\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n\n    wrapX(extent, projection);\n    const worldWidth = getWidth(projectionExtent);\n\n    if (getWidth(extent) > worldWidth) {\n      // the extent wraps around on itself\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n    if (extent[0] < projectionExtent[0]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\n      ];\n    }\n    if (extent[2] > projectionExtent[2]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\n      ];\n    }\n  }\n\n  return [extent];\n}\n","/**\n * @module ol/extent/Relationship\n */\n\n/**\n * Relationship to an extent.\n * @enum {number}\n */\nexport default {\n  UNKNOWN: 0,\n  INTERSECTING: 1,\n  ABOVE: 2,\n  RIGHT: 4,\n  BELOW: 8,\n  LEFT: 16,\n};\n","/**\n * @module ol/functions\n */\n\nimport {equals as arrayEquals} from './array.js';\n\n/**\n * Always returns true.\n * @return {boolean} true.\n */\nexport function TRUE() {\n  return true;\n}\n\n/**\n * Always returns false.\n * @return {boolean} false.\n */\nexport function FALSE() {\n  return false;\n}\n\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() {}\n\n/**\n * Wrap a function in another function that remembers the last return.  If the\n * returned function is called twice in a row with the same arguments and the same\n * this object, it will return the value from the first call in the second call.\n *\n * @param {function(...any): ReturnType} fn The function to memoize.\n * @return {function(...any): ReturnType} The memoized function.\n * @template ReturnType\n */\nexport function memoizeOne(fn) {\n  let called = false;\n\n  /** @type {ReturnType} */\n  let lastResult;\n\n  /** @type {Array<any>} */\n  let lastArgs;\n\n  let lastThis;\n\n  return function () {\n    const nextArgs = Array.prototype.slice.call(arguments);\n    if (!called || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\n      called = true;\n      lastThis = this;\n      lastArgs = nextArgs;\n      lastResult = fn.apply(this, arguments);\n    }\n    return lastResult;\n  };\n}\n\n/**\n * @template T\n * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.\n * @return {Promise<T>} A promise for the value.\n */\nexport function toPromise(getter) {\n  function promiseGetter() {\n    let value;\n    try {\n      value = getter();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    if (value instanceof Promise) {\n      return value;\n    }\n    return Promise.resolve(value);\n  }\n  return promiseGetter();\n}\n","/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport {abstract} from '../util.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createEmpty,\n  createOrUpdateEmpty,\n  getHeight,\n  returnOrUpdate,\n} from '../extent.js';\nimport {get as getProjection, getTransform} from '../proj.js';\nimport {memoizeOne} from '../functions.js';\nimport {transform2D} from './flat/transform.js';\n\n/**\n * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available.\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, or `'Circle'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nclass Geometry extends BaseObject {\n  constructor() {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} revision The geometry revision.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    this.simplifyTransformedInternal = memoizeOne(function (\n      revision,\n      squaredTolerance,\n      transform\n    ) {\n      if (!transform) {\n        return this.getSimplifiedGeometry(squaredTolerance);\n      }\n      const clone = this.clone();\n      clone.applyTransform(transform);\n      return clone.getSimplifiedGeometry(squaredTolerance);\n    });\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {Geometry} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this.simplifyTransformedInternal(\n      this.getRevision(),\n      squaredTolerance,\n      transform\n    );\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  clone() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const coord = this.getClosestPoint([x, y]);\n    return coord[0] === x && coord[1] === y;\n  }\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate} [closestPoint] Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  getClosestPoint(point, closestPoint) {\n    closestPoint = closestPoint ? closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  }\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  getExtent(extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      const extent = this.computeExtent(this.extent_);\n      if (isNaN(extent[0]) || isNaN(extent[1])) {\n        createOrUpdateEmpty(extent);\n      }\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, extent);\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    abstract();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    abstract();\n  }\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n   * algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return abstract();\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {Type} Geometry type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   */\n  applyTransform(transformFn) {\n    abstract();\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  intersectsExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    abstract();\n  }\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  transform(source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    const sourceProj = getProjection(source);\n    const transformFn =\n      sourceProj.getUnits() == 'tile-pixels'\n        ? function (inCoordinates, outCoordinates, stride) {\n            const pixelExtent = sourceProj.getExtent();\n            const projectedExtent = sourceProj.getWorldExtent();\n            const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n            composeTransform(\n              tmpTransform,\n              projectedExtent[0],\n              projectedExtent[3],\n              scale,\n              -scale,\n              0,\n              0,\n              0\n            );\n            transform2D(\n              inCoordinates,\n              0,\n              inCoordinates.length,\n              stride,\n              tmpTransform,\n              outCoordinates\n            );\n            return getTransform(sourceProj, destination)(\n              inCoordinates,\n              outCoordinates,\n              stride\n            );\n          }\n        : getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  }\n}\n\nexport default Geometry;\n","/**\n * @module ol/geom/Point\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {containsXY, createOrUpdateFromCoordinate} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nclass Point extends SimpleGeometry {\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    this.setCoordinates(coordinates, layout);\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @api\n   */\n  clone() {\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\n    point.applyProperties(this);\n    return point;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[0],\n      flatCoordinates[1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      const stride = this.stride;\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Point';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  }\n\n  /**\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default Point;\n","/**\n * @module ol/geom/LinearRing\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {linearRing as linearRingArea} from './flat/area.js';\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nclass LinearRing extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LinearRing} Clone.\n   * @api\n   */\n  clone() {\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingArea(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LinearRing} Simplified LinearRing.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    return new LinearRing(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'LinearRing';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the linear ring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default LinearRing;\n","/**\n * @module ol/geom/Polygon\n */\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY, getCenter, isEmpty} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\nimport {linearRings as linearRingsArea} from './flat/area.js';\nimport {linearRingsContainsXY} from './flat/contains.js';\nimport {modulo} from '../math.js';\nimport {quantizeArray} from './flat/simplify.js';\nimport {offset as sphereOffset} from '../sphere.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nclass Polygon extends SimpleGeometry {\n  /**\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n   *     Array of linear rings that define the polygon. The first linear ring of the\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\n   *     an array of vertices' coordinates where the first coordinate and the last are\n   *     equivalent. (For internal use, flat coordinates in combination with\n   *     `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatInteriorPoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.ends_ = ends;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n  appendLinearRing(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @api\n   */\n  clone() {\n    const polygon = new Polygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice()\n    );\n    polygon.applyProperties(this);\n    return polygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingsContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      x,\n      y\n    );\n  }\n\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingsArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * @return {Array<number>} Interior point.\n   */\n  getFlatInteriorPoint() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.ends_,\n        this.stride,\n        flatCenter,\n        0\n      );\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoint_;\n  }\n\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoint() {\n    return new Point(this.getFlatInteriorPoint(), 'XYM');\n  }\n\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  getLinearRingCount() {\n    return this.ends_.length;\n  }\n\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing|null} Linear ring.\n   * @api\n   */\n  getLinearRing(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LinearRing(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index]\n      ),\n      this.layout\n    );\n  }\n\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n  getLinearRings() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const linearRings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const linearRing = new LinearRing(\n        flatCoordinates.slice(offset, end),\n        layout\n      );\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(\n          this.orientedFlatCoordinates_,\n          0,\n          this.ends_,\n          this.stride\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Polygon} Simplified Polygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds\n    );\n    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Polygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default Polygon;\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, n, sphereRadius) {\n  n = n ? n : 32;\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n  for (let i = 0; i < n; ++i) {\n    extend(\n      flatCoordinates,\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, sphereRadius)\n    );\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n  if (isEmpty(extent)) {\n    throw new Error('Cannot create polygon from empty extent');\n  }\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const flatCoordinates = [\n    minX,\n    minY,\n    minX,\n    maxY,\n    maxX,\n    maxY,\n    maxX,\n    minY,\n    minX,\n    minY,\n  ];\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [sides] Number of sides of the polygon. Default is 32.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, sides, angle) {\n  sides = sides ? sides : 32;\n  const stride = circle.getStride();\n  const layout = circle.getLayout();\n  const center = circle.getCenter();\n  const arrayLength = stride * (sides + 1);\n  const flatCoordinates = new Array(arrayLength);\n  for (let i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n    for (let j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n  const ends = [flatCoordinates.length];\n  const polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), angle);\n  return polygon;\n}\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, angle) {\n  const flatCoordinates = polygon.getFlatCoordinates();\n  const stride = polygon.getStride();\n  const sides = flatCoordinates.length / stride - 1;\n  const startAngle = angle ? angle : 0;\n  for (let i = 0; i <= sides; ++i) {\n    const offset = i * stride;\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n  polygon.changed();\n}\n","/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport {abstract} from '../util.js';\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nclass SimpleGeometry extends Geometry {\n  constructor() {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates = null;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromFlatCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Array<*> | null} Coordinates.\n   */\n  getCoordinates() {\n    return abstract();\n  }\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getFlatCoordinates() {\n    return this.flatCoordinates;\n  }\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  getLastCoordinate() {\n    return this.flatCoordinates.slice(\n      this.flatCoordinates.length - this.stride\n    );\n  }\n\n  /**\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n   * @api\n   */\n  getLayout() {\n    return this.layout;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometry =\n      this.getSimplifiedGeometryInternal(squaredTolerance);\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    }\n    // Simplification did not actually remove any coordinates.  We now know\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\n    // than or equal to the current squaredTolerance will also not have any\n    // effect.  This allows us to short circuit simplification (saving CPU\n    // cycles) and prevents the cache of simplified geometries from filling\n    // up with useless identical copies of this geometry (saving memory).\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride;\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  }\n\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  setCoordinates(coordinates, layout) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  setLayout(layout, coordinates, nesting) {\n    /** @type {number} */\n    let stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (let i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = 'XY';\n          this.stride = 2;\n          return;\n        }\n        coordinates = /** @type {Array} */ (coordinates[0]);\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      rotate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        angle,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      scale(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        sx,\n        sy,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      translate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        deltaX,\n        deltaY,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n}\n\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  let layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  let stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  const stride = simpleGeometry.getStride();\n  return transform2D(\n    flatCoordinates,\n    0,\n    flatCoordinates.length,\n    stride,\n    transform,\n    dest\n  );\n}\n\nexport default SimpleGeometry;\n","/**\n * @module ol/geom/flat/area\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n  let twiceArea = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n  let area = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    area += linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n  return area;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  let area = 0;\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    area += linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n  return area;\n}\n","/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1]\n      );\n    }\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/deflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(\n  flatCoordinates,\n  offset,\n  coordinates,\n  stride\n) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    const coordinate = coordinates[i];\n    for (let j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatess,\n  stride,\n  ends\n) {\n  ends = ends ? ends : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\n    const end = deflateCoordinates(\n      flatCoordinates,\n      offset,\n      coordinatess[j],\n      stride\n    );\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatesss,\n  stride,\n  endss\n) {\n  endss = endss ? endss : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    const ends = deflateCoordinatesArray(\n      flatCoordinates,\n      offset,\n      coordinatesss[j],\n      stride,\n      endss[i]\n    );\n    if (ends.length === 0) {\n      ends[0] = offset;\n    }\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n}\n","/**\n * @module ol/geom/flat/inflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  coordinates\n) {\n  coordinates = coordinates !== undefined ? coordinates : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  coordinatess\n) {\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\n  let i = 0;\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\n    const end = ends[j];\n    coordinatess[i++] = inflateCoordinates(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      coordinatess[i]\n    );\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  coordinatesss\n) {\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\n  let i = 0;\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\n    const ends = endss[j];\n    coordinatesss[i++] =\n      ends.length === 1 && ends[0] === offset\n        ? []\n        : inflateCoordinatesArray(\n            flatCoordinates,\n            offset,\n            ends,\n            stride,\n            coordinatesss[i]\n          );\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n","/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {ascending} from '../../array.js';\nimport {linearRingsContainsXY} from './contains.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  flatCenters,\n  flatCentersOffset,\n  dest\n) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(ascending);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  }\n  return [pointX, y, maxSegmentLength];\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  flatCenters\n) {\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      flatCenters,\n      2 * i,\n      interiorPoints\n    );\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  containsExtent,\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {forEach as forEachSegment} from './segments.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  const coordinatesExtent = extendFlatCoordinates(\n    createEmpty(),\n    flatCoordinates,\n    offset,\n    end,\n    stride\n  );\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    }\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/reverse\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    for (let i = 0; i < stride; ++i) {\n      const tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n    offset += stride;\n    end -= stride;\n  }\n}\n","/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      right\n    );\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to construct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride)\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n","/**\n * @module ol/geom/flat/transform\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  transform,\n  dest\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const x = flatCoordinates[j];\n    const y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  angle,\n  anchor,\n  dest\n) {\n  dest = dest ? dest : [];\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  sx,\n  sy,\n  anchor,\n  dest\n) {\n  dest = dest ? dest : [];\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  deltaX,\n  deltaY,\n  dest\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n","/**\n * @module ol/has\n */\n\nconst ua =\n  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'\n    ? navigator.userAgent.toLowerCase()\n    : '';\n\n/**\n * User agent string says we are dealing with Firefox as browser.\n * @type {boolean}\n */\nexport const FIREFOX = ua.includes('firefox');\n\n/**\n * User agent string says we are dealing with Safari as browser.\n * @type {boolean}\n */\nexport const SAFARI = ua.includes('safari') && !ua.includes('chrom');\n\n/**\n * https://bugs.webkit.org/show_bug.cgi?id=237906\n * @type {boolean}\n */\nexport const SAFARI_BUG_237906 =\n  SAFARI &&\n  (ua.includes('version/15.4') ||\n    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));\n\n/**\n * User agent string says we are dealing with a WebKit engine.\n * @type {boolean}\n */\nexport const WEBKIT = ua.includes('webkit') && !ua.includes('edge');\n\n/**\n * User agent string says we are dealing with a Mac as platform.\n * @type {boolean}\n */\nexport const MAC = ua.includes('macintosh');\n\n/**\n * The ratio between physical pixels and device-independent pixels\n * (dips) on the device (`window.devicePixelRatio`).\n * @const\n * @type {number}\n * @api\n */\nexport const DEVICE_PIXEL_RATIO =\n  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;\n\n/**\n * The execution context is a worker with OffscreenCanvas available.\n * @const\n * @type {boolean}\n */\nexport const WORKER_OFFSCREEN_CANVAS =\n  typeof WorkerGlobalScope !== 'undefined' &&\n  typeof OffscreenCanvas !== 'undefined' &&\n  self instanceof WorkerGlobalScope; //eslint-disable-line\n\n/**\n * Image.prototype.decode() is supported.\n * @type {boolean}\n */\nexport const IMAGE_DECODE =\n  typeof Image !== 'undefined' && Image.prototype.decode;\n\n/**\n * createImageBitmap() is supported.\n * @type {boolean}\n */\nexport const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';\n\n/**\n * @type {boolean}\n */\nexport const PASSIVE_EVENT_LISTENERS = (function () {\n  let passive = false;\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passive = true;\n      },\n    });\n\n    window.addEventListener('_', null, options);\n    window.removeEventListener('_', null, options);\n  } catch (error) {\n    // passive not supported\n  }\n  return passive;\n})();\n","/**\n * @module ol/layer/Base\n */\nimport BaseObject from '../Object.js';\nimport LayerProperty from './Property.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {clamp} from '../math.js';\n\n/**\n * A css color, or a function called with a view resolution returning a css color.\n *\n * @typedef {string|function(number):string} BackgroundColor\n * @api\n */\n\n/**\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\n * is observable, and has get/set accessors.\n *\n * @api\n */\nclass BaseLayer extends BaseObject {\n  /**\n   * @param {Options} options Layer options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {BackgroundColor|false}\n     * @private\n     */\n    this.background_ = options.background;\n\n    /**\n     * @type {Object<string, *>}\n     */\n    const properties = Object.assign({}, options);\n    if (typeof options.properties === 'object') {\n      delete properties.properties;\n      Object.assign(properties, options.properties);\n    }\n\n    properties[LayerProperty.OPACITY] =\n      options.opacity !== undefined ? options.opacity : 1;\n    assert(\n      typeof properties[LayerProperty.OPACITY] === 'number',\n      'Layer opacity must be a number'\n    );\n\n    properties[LayerProperty.VISIBLE] =\n      options.visible !== undefined ? options.visible : true;\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\n    properties[LayerProperty.MAX_RESOLUTION] =\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[LayerProperty.MIN_RESOLUTION] =\n      options.minResolution !== undefined ? options.minResolution : 0;\n    properties[LayerProperty.MIN_ZOOM] =\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\n    properties[LayerProperty.MAX_ZOOM] =\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.className_ =\n      properties.className !== undefined ? properties.className : 'ol-layer';\n    delete properties.className;\n\n    this.setProperties(properties);\n\n    /**\n     * @type {import(\"./Layer.js\").State}\n     * @private\n     */\n    this.state_ = null;\n  }\n\n  /**\n   * Get the background for this layer.\n   * @return {BackgroundColor|false} Layer background.\n   */\n  getBackground() {\n    return this.background_;\n  }\n\n  /**\n   * @return {string} CSS class name.\n   */\n  getClassName() {\n    return this.className_;\n  }\n\n  /**\n   * This method is not meant to be called by layers or layer renderers because the state\n   * is incorrect if the layer is included in a layer group.\n   *\n   * @param {boolean} [managed] Layer is managed.\n   * @return {import(\"./Layer.js\").State} Layer state.\n   */\n  getLayerState(managed) {\n    /** @type {import(\"./Layer.js\").State} */\n    const state =\n      this.state_ ||\n      /** @type {?} */ ({\n        layer: this,\n        managed: managed === undefined ? true : managed,\n      });\n    const zIndex = this.getZIndex();\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    state.minZoom = this.getMinZoom();\n    state.maxZoom = this.getMaxZoom();\n    this.state_ = state;\n\n    return state;\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be\n   *     modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    return abstract();\n  }\n\n  /**\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n  getExtent() {\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\n      this.get(LayerProperty.EXTENT)\n    );\n  }\n\n  /**\n   * Return the maximum resolution of the layer. Returns Infinity if\n   * the layer has no maximum resolution set.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMaxResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum resolution of the layer. Returns 0 if\n   * the layer has no minimum resolution set.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMinResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum zoom level of the layer. Returns -Infinity if\n   * the layer has no minimum zoom set.\n   * @return {number} The minimum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\n  }\n\n  /**\n   * Return the maximum zoom level of the layer. Returns Infinity if\n   * the layer has no maximum zoom set.\n   * @return {number} The maximum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\n  }\n\n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n  getOpacity() {\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    return abstract();\n  }\n\n  /**\n   * Return the value of this layer's `visible` property. To find out whether the layer\n   * is visible on a map, use `isVisible()` instead.\n   * @return {boolean} The value of the `visible` property of the layer.\n   * @observable\n   * @api\n   */\n  getVisible() {\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\n  }\n\n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. Returns undefined if the layer is unmanaged.\n   * @return {number|undefined} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n  getZIndex() {\n    return /** @type {number|undefined} */ (this.get(LayerProperty.Z_INDEX));\n  }\n\n  /**\n   * Sets the background color.\n   * @param {BackgroundColor} [background] Background color.\n   */\n  setBackground(background) {\n    this.background_ = background;\n    this.changed();\n  }\n\n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n  setExtent(extent) {\n    this.set(LayerProperty.EXTENT, extent);\n  }\n\n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMaxResolution(maxResolution) {\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n  }\n\n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMinResolution(minResolution) {\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n  }\n\n  /**\n   * Set the maximum zoom (exclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} maxZoom The maximum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMaxZoom(maxZoom) {\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\n  }\n\n  /**\n   * Set the minimum zoom (inclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} minZoom The minimum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMinZoom(minZoom) {\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\n  }\n\n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n  setOpacity(opacity) {\n    assert(typeof opacity === 'number', 'Layer opacity must be a number');\n    this.set(LayerProperty.OPACITY, opacity);\n  }\n\n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n  setVisible(visible) {\n    this.set(LayerProperty.VISIBLE, visible);\n  }\n\n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n  setZIndex(zindex) {\n    this.set(LayerProperty.Z_INDEX, zindex);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state_) {\n      this.state_.layer = null;\n      this.state_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default BaseLayer;\n","/**\n * @module ol/layer/Layer\n */\nimport BaseLayer from './Base.js';\nimport EventType from '../events/EventType.js';\nimport LayerProperty from './Property.js';\nimport RenderEventType from '../render/EventType.js';\nimport View from '../View.js';\nimport {assert} from '../asserts.js';\nimport {intersects} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../Map.js\").FrameState):HTMLElement} RenderFunction\n */\n\n/**\n * @typedef {'sourceready'|'change:source'} LayerEventType\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     LayerEventType, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|LayerEventType|\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\n * construction.\n * @property {import(\"../Map.js\").default|null} [map] Map.\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\n * HTML element. Will overwrite the default rendering for the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./Layer.js\").default} layer Layer.\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\n * @property {boolean} visible Visible.\n * @property {boolean} managed Managed.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {number | undefined} zIndex ZIndex.\n * @property {number} maxResolution Maximum resolution.\n * @property {number} minResolution Minimum resolution.\n * @property {number} minZoom Minimum zoom.\n * @property {number} maxZoom Maximum zoom.\n */\n\n/**\n * @classdesc\n * Base class from which all layer types are derived. This should only be instantiated\n * in the case where a custom layer is added to the map with a custom `render` function.\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\n *\n * A visual representation of raster or vector map data.\n * Layers group together those properties that pertain to how the data is to be\n * displayed, irrespective of the source of that data.\n *\n * Layers are usually added to a map with [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\n * internally. These unmanaged layers are associated with the map using\n * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.\n *\n * A generic `change` event is fired when the state of the source changes.\n * A `sourceready` event is fired when the layer's source is ready.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @fires import(\"../events/Event.js\").BaseEvent#sourceready\n *\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\n * @api\n */\nclass Layer extends BaseLayer {\n  /**\n   * @param {Options<SourceType>} options Layer options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.source;\n\n    super(baseOptions);\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {LayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapPrecomposeKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapRenderKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceChangeKey_ = null;\n\n    /**\n     * @private\n     * @type {RendererType}\n     */\n    this.renderer_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.sourceReady_ = false;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.rendered = false;\n\n    // Overwrite default render method with a custom one\n    if (options.render) {\n      this.render = options.render;\n    }\n\n    if (options.map) {\n      this.setMap(options.map);\n    }\n\n    this.addChangeListener(\n      LayerProperty.SOURCE,\n      this.handleSourcePropertyChange_\n    );\n\n    const source = options.source\n      ? /** @type {SourceType} */ (options.source)\n      : null;\n    this.setSource(source);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    array = array ? array : [];\n    array.push(this);\n    return array;\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    states = states ? states : [];\n    states.push(this.getLayerState());\n    return states;\n  }\n\n  /**\n   * Get the layer source.\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n  getSource() {\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\n  }\n\n  /**\n   * @return {SourceType|null} The source being rendered.\n   */\n  getRenderSource() {\n    return this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    const source = this.getSource();\n    return !source ? 'undefined' : source.getState();\n  }\n\n  /**\n   * @private\n   */\n  handleSourceChange_() {\n    this.changed();\n    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {\n      return;\n    }\n    this.sourceReady_ = true;\n    this.dispatchEvent('sourceready');\n  }\n\n  /**\n   * @private\n   */\n  handleSourcePropertyChange_() {\n    if (this.sourceChangeKey_) {\n      unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    this.sourceReady_ = false;\n    const source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = listen(\n        source,\n        EventType.CHANGE,\n        this.handleSourceChange_,\n        this\n      );\n      if (source.getState() === 'ready') {\n        this.sourceReady_ = true;\n        setTimeout(() => {\n          this.dispatchEvent('sourceready');\n        }, 0);\n      }\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.renderer_) {\n      return Promise.resolve([]);\n    }\n    return this.renderer_.getFeatures(pixel);\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    if (!this.renderer_ || !this.rendered) {\n      return null;\n    }\n    return this.renderer_.getData(pixel);\n  }\n\n  /**\n   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and\n   * extent, not set to `visible: false`, and not inside a layer group that is set\n   * to `visible: false`.\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\n   * Only required when the layer is not added to a map.\n   * @return {boolean} The layer is visible in the map view.\n   * @api\n   */\n  isVisible(view) {\n    let frameState;\n    const map = this.getMapInternal();\n    if (!view && map) {\n      view = map.getView();\n    }\n    if (view instanceof View) {\n      frameState = {\n        viewState: view.getState(),\n        extent: view.calculateExtent(),\n      };\n    } else {\n      frameState = view;\n    }\n    if (!frameState.layerStatesArray && map) {\n      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();\n    }\n    let layerState;\n    if (frameState.layerStatesArray) {\n      layerState = frameState.layerStatesArray.find(\n        (layerState) => layerState.layer === this\n      );\n    } else {\n      layerState = this.getLayerState();\n    }\n\n    const layerExtent = this.getExtent();\n\n    return (\n      inView(layerState, frameState.viewState) &&\n      (!layerExtent || intersects(layerExtent, frameState.extent))\n    );\n  }\n\n  /**\n   * Get the attributions of the source of this layer for the given view.\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\n   * Only required when the layer is not added to a map.\n   * @return {Array<string>} Attributions for this layer at the given view.\n   * @api\n   */\n  getAttributions(view) {\n    if (!this.isVisible(view)) {\n      return [];\n    }\n    let getAttributions;\n    const source = this.getSource();\n    if (source) {\n      getAttributions = source.getAttributions();\n    }\n    if (!getAttributions) {\n      return [];\n    }\n    const frameState =\n      view instanceof View ? view.getViewStateAndExtent() : view;\n    let attributions = getAttributions(frameState);\n    if (!Array.isArray(attributions)) {\n      attributions = [attributions];\n    }\n    return attributions;\n  }\n\n  /**\n   * In charge to manage the rendering of the layer. One layer type is\n   * bounded with one layer renderer.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  render(frameState, target) {\n    const layerRenderer = this.getRenderer();\n\n    if (layerRenderer.prepareFrame(frameState)) {\n      this.rendered = true;\n      return layerRenderer.renderFrame(frameState, target);\n    }\n    return null;\n  }\n\n  /**\n   * Called when a layer is not visible during a map render.\n   */\n  unrender() {\n    this.rendered = false;\n  }\n\n  /**\n   * For use inside the library only.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMapInternal(map) {\n    if (!map) {\n      this.unrender();\n    }\n    this.set(LayerProperty.MAP, map);\n  }\n\n  /**\n   * For use inside the library only.\n   * @return {import(\"../Map.js\").default|null} Map.\n   */\n  getMapInternal() {\n    return this.get(LayerProperty.MAP);\n  }\n\n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link module:ol/Map~Map#addLayer} instead.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    if (this.mapPrecomposeKey_) {\n      unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = listen(\n        map,\n        RenderEventType.PRECOMPOSE,\n        function (evt) {\n          const renderEvent =\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\n          const layerState = this.getLayerState(false);\n          assert(\n            !layerStatesArray.some(function (arrayLayerState) {\n              return arrayLayerState.layer === layerState.layer;\n            }),\n            'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.'\n          );\n          layerStatesArray.push(layerState);\n        },\n        this\n      );\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the layer source.\n   * @param {SourceType|null} source The layer source.\n   * @observable\n   * @api\n   */\n  setSource(source) {\n    this.set(LayerProperty.SOURCE, source);\n  }\n\n  /**\n   * Get the renderer for this layer.\n   * @return {RendererType|null} The layer renderer.\n   */\n  getRenderer() {\n    if (!this.renderer_) {\n      this.renderer_ = this.createRenderer();\n    }\n    return this.renderer_;\n  }\n\n  /**\n   * @return {boolean} The layer has a renderer.\n   */\n  hasRenderer() {\n    return !!this.renderer_;\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {RendererType} A layer renderer.\n   * @protected\n   */\n  createRenderer() {\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.renderer_) {\n      this.renderer_.dispose();\n      delete this.renderer_;\n    }\n\n    this.setSource(null);\n    super.disposeInternal();\n  }\n}\n\n/**\n * Return `true` if the layer is visible and if the provided view state\n * has resolution and zoom levels that are in range of the layer's min/max.\n * @param {State} layerState Layer state.\n * @param {import(\"../View.js\").State} viewState View state.\n * @return {boolean} The layer is visible at the given view state.\n */\nexport function inView(layerState, viewState) {\n  if (!layerState.visible) {\n    return false;\n  }\n  const resolution = viewState.resolution;\n  if (\n    resolution < layerState.minResolution ||\n    resolution >= layerState.maxResolution\n  ) {\n    return false;\n  }\n  const zoom = viewState.zoom;\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\n}\n\nexport default Layer;\n","/**\n * @module ol/layer/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  OPACITY: 'opacity',\n  VISIBLE: 'visible',\n  EXTENT: 'extent',\n  Z_INDEX: 'zIndex',\n  MAX_RESOLUTION: 'maxResolution',\n  MIN_RESOLUTION: 'minResolution',\n  MAX_ZOOM: 'maxZoom',\n  MIN_ZOOM: 'minZoom',\n  SOURCE: 'source',\n  MAP: 'map',\n};\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true}\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @api\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n}\n\nexport default DataTile;\n","/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8Array(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<DataTile>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n      const getTile = options.getTileFunction;\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8Array;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0]\n      );\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n      dataSources.push({\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n        data: new Uint8Array(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const targetWidth = typeof size === 'number' ? size : size[0];\n      const targetHeight = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      let dataR, dataU;\n\n      const bytesPerPixel = dataSources[0].bytesPerPixel;\n\n      const reprojs = Math.ceil(bytesPerPixel / 3);\n      for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n        const sources = [];\n        for (let i = 0, len = dataSources.length; i < len; ++i) {\n          const dataSource = dataSources[i];\n          const buffer = dataSource.data;\n          const pixelSize = dataSource.pixelSize;\n          const width = pixelSize[0];\n          const height = pixelSize[1];\n          const context = createCanvasContext2D(width, height, canvasPool);\n          const imageData = context.createImageData(width, height);\n          const data = imageData.data;\n          let offset = reproj * 3;\n          for (let j = 0, len = data.length; j < len; j += 4) {\n            data[j] = buffer[offset];\n            data[j + 1] = buffer[offset + 1];\n            data[j + 2] = buffer[offset + 2];\n            data[j + 3] = 255;\n            offset += bytesPerPixel;\n          }\n          context.putImageData(imageData, 0, 0);\n          sources.push({\n            extent: dataSource.extent,\n            image: context.canvas,\n          });\n        }\n\n        const canvas = renderReprojected(\n          targetWidth,\n          targetHeight,\n          this.pixelRatio_,\n          sourceResolution,\n          this.sourceTileGrid_.getExtent(),\n          targetResolution,\n          targetExtent,\n          this.triangulation_,\n          sources,\n          this.gutter_,\n          false,\n          false\n        );\n\n        for (let i = 0, len = sources.length; i < len; ++i) {\n          const canvas = sources[i].image;\n          const context = canvas.getContext('2d');\n          releaseCanvas(context);\n          canvasPool.push(context.canvas);\n        }\n\n        const context = canvas.getContext('2d');\n        const imageData = context.getImageData(\n          0,\n          0,\n          canvas.width,\n          canvas.height\n        );\n\n        releaseCanvas(context);\n        canvasPool.push(canvas);\n\n        if (!dataR) {\n          dataU = new Uint8Array(\n            bytesPerPixel * imageData.width * imageData.height\n          );\n          dataR = new dataSources[0].dataType(dataU.buffer);\n        }\n\n        const data = imageData.data;\n        let offset = reproj * 3;\n        for (let i = 0, len = data.length; i < len; i += 4) {\n          if (data[i + 3] === 255) {\n            dataU[offset] = data[i];\n            dataU[offset + 1] = data[i + 1];\n            dataU[offset + 2] = data[i + 2];\n          } else {\n            dataU[offset] = 0;\n            dataU[offset + 1] = 0;\n            dataU[offset + 2] = 0;\n          }\n          offset += bytesPerPixel;\n        }\n      }\n\n      this.reprojData_ = dataR;\n      this.reprojSize_ = [\n        Math.round(targetWidth * this.pixelRatio_),\n        Math.round(targetHeight * this.pixelRatio_),\n      ];\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach((tile) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(\n        tile,\n        EventType.CHANGE,\n        function () {\n          const state = tile.getState();\n          if (\n            state == TileState.LOADED ||\n            state == TileState.ERROR ||\n            state == TileState.EMPTY\n          ) {\n            unlistenByKey(sourceListenKey);\n            leftToLoad--;\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        },\n        this\n      );\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function (tile) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n","/**\n * @module ol/webgl/BaseTileRepresentation\n */\n\nimport EventTarget from '../events/Target.js';\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport TileState from '../TileState.js';\nimport {abstract} from '../util.js';\n\n/**\n * @typedef {import(\"../Tile.js\").default} BaseTileType\n */\n\n/**\n * @template {BaseTileType} TileType\n * @typedef {Object} TileRepresentationOptions\n * @property {TileType} tile The tile.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid Tile grid.\n * @property {import(\"../webgl/Helper.js\").default} helper WebGL helper.\n * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.\n */\n\n/**\n * @classdesc\n * Base class for representing a tile in a webgl context\n * @template {import(\"../Tile.js\").default} TileType\n * @abstract\n */\nclass BaseTileRepresentation extends EventTarget {\n  /**\n   * @param {TileRepresentationOptions<TileType>} options The tile representation options.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * @type {TileType}\n     */\n    this.tile;\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.gutter_ = options.gutter || 0;\n\n    /**\n     * @type {import(\"../webgl/Helper.js\").default}\n     * @protected\n     */\n    this.helper_ = options.helper;\n\n    this.loaded = false;\n    this.ready = false;\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   */\n  setTile(tile) {\n    if (tile !== this.tile) {\n      if (this.tile) {\n        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n      this.tile = tile;\n      this.loaded = tile.getState() === TileState.LOADED;\n      if (this.loaded) {\n        this.uploadTile();\n      } else {\n        if (tile instanceof ImageTile) {\n          const image = tile.getImage();\n          if (image instanceof Image && !image.crossOrigin) {\n            image.crossOrigin = 'anonymous';\n          }\n        }\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n    }\n  }\n\n  /**\n   * @abstract\n   * @protected\n   */\n  uploadTile() {\n    abstract();\n  }\n\n  setReady() {\n    this.ready = true;\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  handleTileChange_() {\n    if (this.tile.getState() === TileState.LOADED) {\n      this.loaded = true;\n      this.uploadTile();\n    }\n  }\n\n  disposeInternal() {\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n  }\n}\n\nexport default BaseTileRepresentation;\n","/**\n * @module ol/webgl\n */\n\nimport {SAFARI_BUG_237906} from './has.js';\n\n/**\n * Constants taken from goog.webgl\n */\n\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as\n * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer\n * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).\n * @const\n * @type {number}\n * @api\n */\nexport const ARRAY_BUFFER = 0x8892;\n\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.\n * Index buffers are essentially lists of references to vertices defined in a vertex buffer\n * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.\n * @const\n * @type {number}\n * @api\n */\nexport const ELEMENT_ARRAY_BUFFER = 0x8893;\n\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport const STREAM_DRAW = 0x88e0;\n\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport const STATIC_DRAW = 0x88e4;\n\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport const DYNAMIC_DRAW = 0x88e8;\n\n/**\n * @const\n * @type {number}\n */\nexport const UNSIGNED_BYTE = 0x1401;\n\n/**\n * @const\n * @type {number}\n */\nexport const UNSIGNED_SHORT = 0x1403;\n\n/**\n * @const\n * @type {number}\n */\nexport const UNSIGNED_INT = 0x1405;\n\n/**\n * @const\n * @type {number}\n */\nexport const FLOAT = 0x1406;\n\n/** end of goog.webgl constants\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];\n\n/**\n * @param {HTMLCanvasElement} canvas Canvas.\n * @param {Object} [attributes] Attributes.\n * @return {WebGLRenderingContext} WebGL rendering context.\n */\n// yiming\nexport function getContext(canvas, attributes, request_webgl2 = true) {\n  attributes = Object.assign(\n    {\n      preserveDrawingBuffer: true,\n      antialias: SAFARI_BUG_237906 ? false : true, // https://bugs.webkit.org/show_bug.cgi?id=237906\n    },\n    attributes\n  );\n  const contextsToTry = request_webgl2 ? ['webgl2', ...CONTEXT_IDS] : CONTEXT_IDS\n  const ii = contextsToTry.length;\n  for (let i = 0; i < ii; ++i) {\n    try {\n      const context = canvas.getContext(contextsToTry[i], attributes);\n      if (context) {\n        return /** @type {!WebGLRenderingContext} */ (context);\n      }\n    } catch (e) {\n      // pass\n    }\n  }\n  return null;\n}\n\n/**\n * @type {Array<string>}\n */\nlet supportedExtensions;\n\n/**\n * @return {Array<string>} List of supported WebGL extensions.\n */\nexport function getSupportedExtensions() {\n  if (!supportedExtensions) {\n    const canvas = document.createElement('canvas');\n    const gl = getContext(canvas);\n    if (gl) {\n      supportedExtensions = gl.getSupportedExtensions();\n    }\n  }\n  return supportedExtensions;\n}\n","/**\n * @module ol/webgl/Buffer\n */\nimport {\n  ARRAY_BUFFER,\n  DYNAMIC_DRAW,\n  ELEMENT_ARRAY_BUFFER,\n  STATIC_DRAW,\n  STREAM_DRAW,\n} from '../webgl.js';\nimport {assert} from '../asserts.js';\n\n/**\n * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`\n * or `DYNAMIC_DRAW`.\n * @enum {number}\n */\nexport const BufferUsage = {\n  STATIC_DRAW: STATIC_DRAW,\n  STREAM_DRAW: STREAM_DRAW,\n  DYNAMIC_DRAW: DYNAMIC_DRAW,\n};\n\n/**\n * @classdesc\n * Object used to store an array of data as well as usage information for that data.\n * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on\n * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.\n *\n * To populate the array, you can either use:\n * * A size using `#ofSize(buffer)`\n * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`\n * * A plain array using `#fromArray(array)`\n *\n * Note:\n * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)\n * for more info on buffer usage.\n */\nclass WebGLArrayBuffer {\n  /**\n   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.\n   * Default is `DYNAMIC_DRAW`.\n   */\n  constructor(type, usage) {\n    /**\n     * @private\n     * @type {Float32Array|Uint32Array}\n     */\n    this.array = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.type = type;\n\n    assert(\n      type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER,\n      'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`'\n    );\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.usage = usage !== undefined ? usage : BufferUsage.STATIC_DRAW;\n  }\n\n  /**\n   * Populates the buffer with an array of the given size (all values will be zeroes).\n   * @param {number} size Array size\n   * @return {WebGLArrayBuffer} This\n   */\n  ofSize(size) {\n    this.array = new (getArrayClassForType(this.type))(size);\n    return this;\n  }\n\n  /**\n   * Populates the buffer with an array of the given size.\n   * @param {Array<number>} array Numerical array\n   * @return {WebGLArrayBuffer} This\n   */\n  fromArray(array) {\n    this.array = getArrayClassForType(this.type).from(array);\n    return this;\n  }\n\n  /**\n   * Populates the buffer with a raw binary array buffer.\n   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been\n   * initialized for the same typed array class.\n   * @return {WebGLArrayBuffer} This\n   */\n  fromArrayBuffer(buffer) {\n    this.array = new (getArrayClassForType(this.type))(buffer);\n    return this;\n  }\n\n  /**\n   * @return {number} Buffer type.\n   */\n  getType() {\n    return this.type;\n  }\n\n  /**\n   * Will return null if the buffer was not initialized\n   * @return {Float32Array|Uint32Array} Array.\n   */\n  getArray() {\n    return this.array;\n  }\n\n  /**\n   * @return {number} Usage.\n   */\n  getUsage() {\n    return this.usage;\n  }\n\n  /**\n   * Will return 0 if the buffer is not initialized\n   * @return {number} Array size\n   */\n  getSize() {\n    return this.array ? this.array.length : 0;\n  }\n}\n\n/**\n * Returns a typed array constructor based on the given buffer type\n * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.\n */\nexport function getArrayClassForType(type) {\n  switch (type) {\n    case ARRAY_BUFFER:\n      return Float32Array;\n    case ELEMENT_ARRAY_BUFFER:\n      return Uint32Array;\n    default:\n      return Float32Array;\n  }\n}\n\nexport default WebGLArrayBuffer;\n","/**\n * @module ol/webgl/TileTexture\n */\n\nimport BaseTileRepresentation from './BaseTileRepresentation.js';\nimport DataTile, {asArrayLike, asImageLike} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport WebGLArrayBuffer from './Buffer.js';\nimport {ARRAY_BUFFER, STATIC_DRAW} from '../webgl.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {toSize} from '../size.js';\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction bindAndConfigure(gl, texture, interpolate) {\n  const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);\n}\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {import(\"../DataTile.js\").ImageLike} image The image.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadImageTexture(gl, texture, image, interpolate) {\n  bindAndConfigure(gl, texture, interpolate);\n\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n}\n\n/**\n * @param {import(\"./Helper.js\").default} helper The WebGL helper.\n * @param {WebGLTexture} texture The texture.\n * @param {import(\"../DataTile.js\").ArrayLike} data The pixel data.\n * @param {import(\"../size.js\").Size} size The pixel size.\n * @param {number} bandCount The band count.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadDataTexture(\n  helper,\n  texture,\n  data,\n  size,\n  bandCount,\n  interpolate\n) {\n  const gl = helper.getGL();\n  let textureType;\n  let canInterpolate;\n  if (data instanceof Float32Array) {\n    textureType = gl.FLOAT;\n    helper.getExtension('OES_texture_float');\n    const extension = helper.getExtension('OES_texture_float_linear');\n    canInterpolate = extension !== null;\n  } else {\n    textureType = gl.UNSIGNED_BYTE;\n    canInterpolate = true;\n  }\n  bindAndConfigure(gl, texture, interpolate && canInterpolate);\n\n  const bytesPerRow = data.byteLength / size[1];\n  let unpackAlignment = 1;\n  if (bytesPerRow % 8 === 0) {\n    unpackAlignment = 8;\n  } else if (bytesPerRow % 4 === 0) {\n    unpackAlignment = 4;\n  } else if (bytesPerRow % 2 === 0) {\n    unpackAlignment = 2;\n  }\n\n  let format;\n  switch (bandCount) {\n    case 1: {\n      format = gl.LUMINANCE;\n      break;\n    }\n    case 2: {\n      format = gl.LUMINANCE_ALPHA;\n      break;\n    }\n    case 3: {\n      format = gl.RGB;\n      break;\n    }\n    case 4: {\n      format = gl.RGBA;\n      break;\n    }\n    default: {\n      throw new Error(`Unsupported number of bands: ${bandCount}`);\n    }\n  }\n\n  const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    format,\n    size[0],\n    size[1],\n    0,\n    format,\n    textureType,\n    data\n  );\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);\n}\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @typedef {import(\"../DataTile.js\").default|ImageTile|ReprojTile} TileType\n */\n\n/**\n * @extends {BaseTileRepresentation<TileType>}\n */\nclass TileTexture extends BaseTileRepresentation {\n  /**\n   * @param {import(\"./BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options The tile texture options.\n   */\n  constructor(options) {\n    super(options);\n\n    /**\n     * @type {Array<WebGLTexture>}\n     */\n    this.textures = [];\n\n    /**\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n    this.renderSize_ = toSize(\n      options.grid.getTileSize(options.tile.tileCoord[0])\n    );\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = NaN;\n\n    const coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    coords.fromArray([\n      0, // P0\n      1,\n      1, // P1\n      1,\n      1, // P2\n      0,\n      0, // P3\n      0,\n    ]);\n    this.helper_.flushBufferData(coords);\n\n    /**\n     * @type {WebGLArrayBuffer}\n     */\n    this.coords = coords;\n\n    this.setTile(options.tile);\n  }\n\n  uploadTile() {\n    const helper = this.helper_;\n    const gl = helper.getGL();\n    const tile = this.tile;\n\n    this.textures.length = 0;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     */\n    let data;\n\n    if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n      data = tile.getImage();\n    } else {\n      data = tile.getData();\n    }\n\n    const image = asImageLike(data);\n    if (image) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      this.bandCount = 4;\n      uploadImageTexture(gl, texture, image, tile.interpolate);\n      this.setReady();\n      return;\n    }\n\n    data = asArrayLike(data);\n\n    const sourceTileSize = /** @type {DataTile} */ (tile).getSize();\n    const pixelSize = [\n      sourceTileSize[0] + 2 * this.gutter_,\n      sourceTileSize[1] + 2 * this.gutter_,\n    ];\n    const isFloat = data instanceof Float32Array;\n    const pixelCount = pixelSize[0] * pixelSize[1];\n    const DataType = isFloat ? Float32Array : Uint8Array;\n    const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n    const bytesPerRow = data.byteLength / pixelSize[1];\n\n    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n    const textureCount = Math.ceil(this.bandCount / 4);\n\n    if (textureCount === 1) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      uploadDataTexture(\n        helper,\n        texture,\n        data,\n        pixelSize,\n        this.bandCount,\n        tile.interpolate\n      );\n      this.setReady();\n      return;\n    }\n\n    const textureDataArrays = new Array(textureCount);\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n\n      const bandCount =\n        textureIndex < textureCount - 1 ? 4 : ((this.bandCount - 1) % 4) + 1;\n      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);\n    }\n\n    let dataIndex = 0;\n    let rowOffset = 0;\n    const colCount = pixelSize[0] * this.bandCount;\n    for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n      for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n        const dataValue = data[rowOffset + colIndex];\n\n        const pixelIndex = Math.floor(dataIndex / this.bandCount);\n        const bandIndex = colIndex % this.bandCount;\n        const textureIndex = Math.floor(bandIndex / 4);\n        const textureData = textureDataArrays[textureIndex];\n        const bandCount = textureData.length / pixelCount;\n        const textureBandIndex = bandIndex % 4;\n        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;\n\n        ++dataIndex;\n      }\n      rowOffset += bytesPerRow / bytesPerElement;\n    }\n\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = this.textures[textureIndex];\n      const textureData = textureDataArrays[textureIndex];\n      const bandCount = textureData.length / pixelCount;\n      uploadDataTexture(\n        helper,\n        texture,\n        textureData,\n        pixelSize,\n        bandCount,\n        tile.interpolate\n      );\n    }\n\n    this.setReady();\n  }\n\n  disposeInternal() {\n    const gl = this.helper_.getGL();\n    this.helper_.deleteBuffer(this.coords);\n    for (let i = 0; i < this.textures.length; ++i) {\n      gl.deleteTexture(this.textures[i]);\n    }\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n  }\n\n  /**\n   * @param {import(\"../DataTile.js\").ImageLike} image The image.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {Uint8ClampedArray|null} The data.\n   * @private\n   */\n  getImagePixelData_(image, renderCol, renderRow) {\n    const gutter = this.gutter_;\n    const renderWidth = this.renderSize_[0];\n    const renderHeight = this.renderSize_[1];\n\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    const sourceWidth = image.width;\n    const sourceHeight = image.height;\n\n    const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;\n    const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;\n\n    const sourceCol =\n      gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n\n    const sourceRow =\n      gutter +\n      Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n\n    let data;\n    try {\n      pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import(\"../DataTile.js\").ArrayLike} data The data.\n   * @param {import(\"../size.js\").Size} sourceSize The size.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\n   * @private\n   */\n  getArrayPixelData_(data, sourceSize, renderCol, renderRow) {\n    const gutter = this.gutter_;\n    const renderWidth = this.renderSize_[0];\n    const renderHeight = this.renderSize_[1];\n\n    const sourceWidthWithoutGutter = sourceSize[0];\n    const sourceHeightWithoutGutter = sourceSize[1];\n    const sourceWidth = sourceWidthWithoutGutter + 2 * gutter;\n    const sourceHeight = sourceHeightWithoutGutter + 2 * gutter;\n\n    const sourceCol =\n      gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n\n    const sourceRow =\n      gutter +\n      Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n\n    if (data instanceof DataView) {\n      const bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);\n      const offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);\n      const buffer = data.buffer.slice(offset, offset + bytesPerPixel);\n      return new DataView(buffer);\n    }\n\n    const offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);\n    return data.slice(offset, offset + this.bandCount);\n  }\n\n  /**\n   * Get data for a pixel.  If the tile is not loaded, null is returned.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\n   */\n  getPixelData(renderCol, renderRow) {\n    if (!this.loaded) {\n      return null;\n    }\n\n    if (this.tile instanceof DataTile) {\n      const data = this.tile.getData();\n      const arrayData = asArrayLike(data);\n      if (arrayData) {\n        const sourceSize = this.tile.getSize();\n        return this.getArrayPixelData_(\n          arrayData,\n          sourceSize,\n          renderCol,\n          renderRow\n        );\n      }\n      return this.getImagePixelData_(asImageLike(data), renderCol, renderRow);\n    }\n\n    return this.getImagePixelData_(this.tile.getImage(), renderCol, renderRow);\n  }\n}\n\nexport default TileTexture;\n","/**\n * @module ol/webgl/ContextEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  LOST: 'webglcontextlost',\n  RESTORED: 'webglcontextrestored',\n};\n","/**\n * @module ol/webgl/PostProcessingPass\n */\n\nimport {getUid} from '../util.js';\n\nconst DEFAULT_VERTEX_SHADER = `\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n`;\n\nconst DEFAULT_FRAGMENT_SHADER = `\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n`;\n\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {WebGLUniformLocation} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *   uniform float u_opacity;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n *   }\n *   ```\n */\nclass WebGLPostProcessingPass {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    this.gl_ = options.webGlContext;\n    const gl = this.gl_;\n\n    this.scaleRatio_ = options.scaleRatio || 1;\n\n    this.renderTargetTexture_ = gl.createTexture();\n    this.renderTargetTextureSize_ = null;\n\n    this.frameBuffer_ = gl.createFramebuffer();\n    this.depthBuffer_ = gl.createRenderbuffer();\n\n    // compile the program for the frame buffer\n    // TODO: make compilation errors show up\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(\n      vertexShader,\n      options.vertexShader || DEFAULT_VERTEX_SHADER\n    );\n    gl.compileShader(vertexShader);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(\n      fragmentShader,\n      options.fragmentShader || DEFAULT_FRAGMENT_SHADER\n    );\n    gl.compileShader(fragmentShader);\n    this.renderTargetProgram_ = gl.createProgram();\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\n    gl.linkProgram(this.renderTargetProgram_);\n\n    // bind the vertices buffer for the frame buffer\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\n    const verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(verticesArray),\n      gl.STATIC_DRAW\n    );\n\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(\n      this.renderTargetProgram_,\n      'a_position'\n    );\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(\n      this.renderTargetProgram_,\n      'u_screenSize'\n    );\n    this.renderTargetOpacityLocation_ = gl.getUniformLocation(\n      this.renderTargetProgram_,\n      'u_opacity'\n    );\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(\n      this.renderTargetProgram_,\n      'u_image'\n    );\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    options.uniforms &&\n      Object.keys(options.uniforms).forEach((name) => {\n        this.uniforms_.push({\n          value: options.uniforms[name],\n          location: gl.getUniformLocation(this.renderTargetProgram_, name),\n        });\n      });\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Initialize the render target texture of the post process, make sure it is at the\n   * right size and bind it as a render target for the next draw calls.\n   * The last step to be initialized will be the one where the primitives are rendered.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   */\n  init(frameState) {\n    const gl = this.getGL();\n    const textureSize = [\n      gl.drawingBufferWidth * this.scaleRatio_,\n      gl.drawingBufferHeight * this.scaleRatio_,\n    ];\n\n    // rendering goes to my buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.getDepthBuffer());\n    gl.viewport(0, 0, textureSize[0], textureSize[1]);\n\n    // if size has changed: adjust canvas & render target texture\n    if (\n      !this.renderTargetTextureSize_ ||\n      this.renderTargetTextureSize_[0] !== textureSize[0] ||\n      this.renderTargetTextureSize_[1] !== textureSize[1]\n    ) {\n      this.renderTargetTextureSize_ = textureSize;\n\n      // create a new texture\n      const level = 0;\n      const internalFormat = gl.RGBA;\n      const border = 0;\n      const format = gl.RGBA;\n      const type = gl.UNSIGNED_BYTE;\n      const data = null;\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        textureSize[0],\n        textureSize[1],\n        border,\n        format,\n        type,\n        data\n      );\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      // bind the texture to the framebuffer\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        this.renderTargetTexture_,\n        0\n      );\n\n      gl.renderbufferStorage(\n        gl.RENDERBUFFER,\n        gl.DEPTH_COMPONENT16,\n        textureSize[0],\n        textureSize[1]\n      );\n      gl.framebufferRenderbuffer(\n        gl.FRAMEBUFFER,\n        gl.DEPTH_ATTACHMENT,\n        gl.RENDERBUFFER,\n        this.depthBuffer_\n      );\n    }\n  }\n\n  /**\n   * Render to the next postprocessing pass (or to the canvas if final pass).\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\n   */\n  apply(frameState, nextPass, preCompose, postCompose) {\n    const gl = this.getGL();\n    const size = frameState.size;\n\n    gl.bindFramebuffer(\n      gl.FRAMEBUFFER,\n      nextPass ? nextPass.getFrameBuffer() : null\n    );\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n\n    if (!nextPass) {\n      // clear the canvas if we are the first to render to it\n      // and preserveDrawingBuffer is true\n      const canvasId = getUid(gl.canvas);\n      if (!frameState.renderTargets[canvasId]) {\n        const attributes = gl.getContextAttributes();\n        if (attributes && attributes.preserveDrawingBuffer) {\n          gl.clearColor(0.0, 0.0, 0.0, 0.0);\n          gl.clearDepth(1.0);\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        }\n\n        frameState.renderTargets[canvasId] = true;\n      }\n    }\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n\n    gl.useProgram(this.renderTargetProgram_);\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n    gl.vertexAttribPointer(\n      this.renderTargetAttribLocation_,\n      2,\n      gl.FLOAT,\n      false,\n      0,\n      0\n    );\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\n\n    const opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;\n    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);\n\n    this.applyUniforms(frameState);\n\n    if (preCompose) {\n      preCompose(gl, frameState);\n    }\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    if (postCompose) {\n      postCompose(gl, frameState);\n    }\n  }\n\n  /**\n   * @return {WebGLFramebuffer} Frame buffer\n   */\n  getFrameBuffer() {\n    return this.frameBuffer_;\n  }\n\n  /**\n   * @return {WebGLRenderbuffer} Depth buffer\n   */\n  getDepthBuffer() {\n    return this.depthBuffer_;\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  applyUniforms(frameState) {\n    const gl = this.getGL();\n\n    let value;\n    let textureSlot = 1;\n    this.uniforms_.forEach(function (uniform) {\n      value =\n        typeof uniform.value === 'function'\n          ? uniform.value(frameState)\n          : uniform.value;\n\n      // apply value based on type\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.texture = gl.createTexture();\n        }\n        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n        if (value instanceof ImageData) {\n          gl.texImage2D(\n            gl.TEXTURE_2D,\n            0,\n            gl.RGBA,\n            gl.RGBA,\n            value.width,\n            value.height,\n            0,\n            gl.UNSIGNED_BYTE,\n            new Uint8Array(value.data)\n          );\n        } else {\n          gl.texImage2D(\n            gl.TEXTURE_2D,\n            0,\n            gl.RGBA,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            value\n          );\n        }\n\n        // fill texture slots\n        gl.uniform1i(uniform.location, textureSlot++);\n      } else if (Array.isArray(value)) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(uniform.location, value[0], value[1]);\n            return;\n          case 3:\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n            return;\n          case 4:\n            gl.uniform4f(\n              uniform.location,\n              value[0],\n              value[1],\n              value[2],\n              value[3]\n            );\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(uniform.location, value);\n      }\n    });\n  }\n}\n\nexport default WebGLPostProcessingPass;\n","/**\n * @module ol/vec/mat4\n */\n\n/**\n * @return {Array<number>} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n/**\n * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Array<number>} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n  mat4[0] = transform[0];\n  mat4[1] = transform[1];\n  mat4[4] = transform[2];\n  mat4[5] = transform[3];\n  mat4[12] = transform[4];\n  mat4[13] = transform[5];\n  return mat4;\n}\n","/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport {\n  FLOAT,\n  UNSIGNED_BYTE,\n  UNSIGNED_INT,\n  UNSIGNED_SHORT,\n  getContext,\n} from '../webgl.js';\nimport {clear} from '../obj.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {create, fromTransform} from '../vec/mat4.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport const ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31,\n};\n\n/**\n * Names of uniforms made available to all shaders.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution',\n  ROTATION: 'u_rotation',\n  VIEWPORT_SIZE_PX: 'u_viewportSizePx',\n  PIXEL_RATIO: 'u_pixelRatio',\n  HIT_DETECTION: 'u_hitDetection',\n};\n\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport const AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT,\n};\n\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../Map.js\").FrameState):UniformLiteralValue} UniformValue\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n * @property {string} [canvasCacheKey] The cache key for the canvas.\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {UniformValue} [prevValue] The previous value.\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @typedef {Object} CanvasCacheItem\n * @property {WebGLRenderingContext} context The context of this canvas.\n * @property {number} users The count of users of this canvas.\n */\n\n/**\n * @type {Object<string,CanvasCacheItem>}\n */\nconst canvasCache = {};\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {string} The shared cache key.\n */\nfunction getSharedCanvasCacheKey(key) {\n  return 'shared/' + key;\n}\n\nlet uniqueCanvasCacheKeyCount = 0;\n\n/**\n * @return {string} The unique cache key.\n */\nfunction getUniqueCanvasCacheKey() {\n  const key = 'unique/' + uniqueCanvasCacheKeyCount;\n  uniqueCanvasCacheKeyCount += 1;\n  return key;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {WebGLRenderingContext} The canvas.\n */\nfunction getOrCreateContext(key) {\n  let cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    const canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    canvas.style.position = 'absolute';\n    canvas.style.left = '0';\n    const context = getContext(canvas);\n    cacheItem = {users: 0, context};\n    canvasCache[key] = cacheItem;\n  }\n\n  cacheItem.users += 1;\n  return cacheItem.context;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n */\nfunction releaseCanvas(key) {\n  const cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    return;\n  }\n\n  cacheItem.users -= 1;\n  if (cacheItem.users > 0) {\n    return;\n  }\n\n  const gl = cacheItem.context;\n  const extension = gl.getExtension('WEBGL_lose_context');\n  if (extension) {\n    extension.loseContext();\n  }\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n\n  delete canvasCache[key];\n}\n\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls; note how a frameState is required to set up a program,\n *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program, frameState);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Specify the attribute names with\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n */\nclass WebGLHelper extends Disposable {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n\n    /** @private */\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\n\n    /** @private */\n    this.boundHandleWebGLContextRestored_ =\n      this.handleWebGLContextRestored.bind(this);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.canvasCacheKey_ = options.canvasCacheKey\n      ? getSharedCanvasCacheKey(options.canvasCacheKey)\n      : getUniqueCanvasCacheKey();\n\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = getOrCreateContext(this.canvasCacheKey_);\n\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n    this.bufferCache_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Object>}\n     */\n    this.extensionCache_ = {};\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.currentProgram_ = null;\n\n    /**\n     * @private\n     * @type boolean\n     */\n    this.needsToBeRecreated_ = false;\n\n    const canvas = this.gl_.canvas;\n\n    canvas.addEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    canvas.addEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetRotateMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetScaleMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.tmpMat4_ = create();\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, WebGLUniformLocation>>}\n     */\n    this.uniformLocationsByProgram_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.attribLocationsByProgram_ = {};\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    if (options.uniforms) {\n      this.setUniforms(options.uniforms);\n    }\n\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n    this.postProcessPasses_ = options.postProcesses\n      ? options.postProcesses.map(\n          (options) =>\n            new WebGLPostProcessingPass({\n              webGlContext: this.gl_,\n              scaleRatio: options.scaleRatio,\n              vertexShader: options.vertexShader,\n              fragmentShader: options.fragmentShader,\n              uniforms: options.uniforms,\n            })\n        )\n      : [new WebGLPostProcessingPass({webGlContext: this.gl_})];\n\n    /**\n     * @type {string|null}\n     * @private\n     */\n    this.shaderCompileErrors_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.startTime_ = Date.now();\n  }\n\n  /**\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n   */\n  setUniforms(uniforms) {\n    this.uniforms_ = [];\n    this.addUniforms(uniforms);\n  }\n\n  /**\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n   */\n  addUniforms(uniforms) {\n    for (const name in uniforms) {\n      this.uniforms_.push({\n        name: name,\n        value: uniforms[name],\n      });\n    }\n  }\n\n  /**\n   * @param {string} canvasCacheKey The canvas cache key.\n   * @return {boolean} The provided key matches the one this helper was constructed with.\n   */\n  canvasCacheKeyMatches(canvasCacheKey) {\n    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\n  }\n\n  /**\n   * Get a WebGL extension.  If the extension is not supported, null is returned.\n   * Extensions are cached after they are enabled for the first time.\n   * @param {string} name The extension name.\n   * @return {Object|null} The extension or null if not supported.\n   */\n  getExtension(name) {\n    if (name in this.extensionCache_) {\n      return this.extensionCache_[name];\n    }\n    const extension = this.gl_.getExtension(name);\n    this.extensionCache_[name] = extension;\n    return extension;\n  }\n\n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n  bindBuffer(buffer) {\n    const gl = this.gl_;\n    const bufferKey = getUid(buffer);\n    let bufferCache = this.bufferCache_[bufferKey];\n    if (!bufferCache) {\n      const webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer,\n        webGlBuffer: webGlBuffer,\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n  }\n\n  /**\n   * Update the data contained in the buffer array; this is required for the\n   * new data to be rendered\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n  flushBufferData(buffer) {\n    const gl = this.gl_;\n    this.bindBuffer(buffer);\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n  }\n\n  /**\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\n   */\n  deleteBuffer(buf) {\n    const gl = this.gl_;\n    const bufferKey = getUid(buf);\n    const bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (bufferCacheEntry && !gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const canvas = this.gl_.canvas;\n    canvas.removeEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    canvas.removeEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    releaseCanvas(this.canvasCacheKey_);\n\n    delete this.gl_;\n  }\n\n  /**\n   * Clear the buffer & set the viewport to draw.\n   * Post process passes will be initialized here, the first one being bound as a render target for\n   * subsequent draw calls.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   * @param {boolean} [enableDepth] If true, enables depth testing.\n   */\n  prepareDraw(frameState, disableAlphaBlend, enableDepth) {\n    const gl = this.gl_;\n    const canvas = this.getCanvas();\n    const size = frameState.size;\n    const pixelRatio = frameState.pixelRatio;\n\n    if (\n      canvas.width !== size[0] * pixelRatio ||\n      canvas.height !== size[1] * pixelRatio\n    ) {\n      canvas.width = size[0] * pixelRatio;\n      canvas.height = size[1] * pixelRatio;\n      canvas.style.width = size[0] + 'px';\n      canvas.style.height = size[1] + 'px';\n    }\n\n    // loop backwards in post processes list\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n      this.postProcessPasses_[i].init(frameState);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.depthRange(0.0, 1.0);\n    gl.clearDepth(1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n    if (enableDepth) {\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthFunc(gl.LEQUAL);\n    } else {\n      gl.disable(gl.DEPTH_TEST);\n    }\n  }\n\n  /**\n   * Prepare a program to use a texture.\n   * @param {WebGLTexture} texture The texture.\n   * @param {number} slot The texture slot.\n   * @param {string} uniformName The corresponding uniform name.\n   */\n  bindTexture(texture, slot, uniformName) {\n    const gl = this.gl_;\n    gl.activeTexture(gl.TEXTURE0 + slot);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.uniform1i(this.getUniformLocation(uniformName), slot);\n  }\n\n  /**\n   * Clear the render target & bind it for future draw operations.\n   * This is similar to `prepareDraw`, only post processes will not be applied.\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   * @param {boolean} [enableDepth] If true, enables depth testing.\n   */\n  prepareDrawToRenderTarget(\n    frameState,\n    renderTarget,\n    disableAlphaBlend,\n    enableDepth\n  ) {\n    const gl = this.gl_;\n    const size = renderTarget.getSize();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getDepthbuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.depthRange(0.0, 1.0);\n    gl.clearDepth(1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n    if (enableDepth) {\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthFunc(gl.LEQUAL);\n    } else {\n      gl.disable(gl.DEPTH_TEST);\n    }\n  }\n\n  /**\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   */\n  drawElements(start, end) {\n    const gl = this.gl_;\n    this.getExtension('OES_element_index_uint');\n\n    const elementType = gl.UNSIGNED_INT;\n    const elementSize = 4;\n\n    const numItems = end - start;\n    const offsetInBytes = start * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  }\n\n  /**\n   * Apply the successive post process passes which will eventually render to the actual canvas.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\n   */\n  finalizeDraw(frameState, preCompose, postCompose) {\n    // apply post processes using the next one as target\n    for (let i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\n      if (i === ii - 1) {\n        this.postProcessPasses_[i].apply(\n          frameState,\n          null,\n          preCompose,\n          postCompose\n        );\n      } else {\n        this.postProcessPasses_[i].apply(\n          frameState,\n          this.postProcessPasses_[i + 1]\n        );\n      }\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getCanvas() {\n    return /** @type {HTMLCanvasElement} */ (this.gl_.canvas);\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  applyFrameState(frameState) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    this.setUniformFloatValue(\n      DefaultUniform.TIME,\n      (Date.now() - this.startTime_) * 0.001\n    );\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(\n      DefaultUniform.RESOLUTION,\n      frameState.viewState.resolution\n    );\n    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);\n    this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [\n      size[0],\n      size[1],\n    ]);\n    this.setUniformFloatValue(DefaultUniform.ROTATION, rotation);\n  }\n\n  /**\n   * Sets the `u_hitDetection` uniform.\n   * @param {boolean} enabled Whether to enable the hit detection code path\n   */\n  applyHitDetectionUniform(enabled) {\n    const loc = this.getUniformLocation(DefaultUniform.HIT_DETECTION);\n    this.getGL().uniform1i(loc, enabled ? 1 : 0);\n\n    // hit detection uses a fixed pixel ratio\n    if (enabled) {\n      this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, 0.5);\n    }\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  applyUniforms(frameState) {\n    const gl = this.gl_;\n\n    let value;\n    let textureSlot = 0;\n    this.uniforms_.forEach((uniform) => {\n      value =\n        typeof uniform.value === 'function'\n          ? uniform.value(frameState)\n          : uniform.value;\n\n      // apply value based on type\n      if (\n        value instanceof HTMLCanvasElement ||\n        value instanceof HTMLImageElement ||\n        value instanceof ImageData\n      ) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.prevValue = undefined;\n          uniform.texture = gl.createTexture();\n        }\n        this.bindTexture(uniform.texture, textureSlot, uniform.name);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n        const imageReady =\n          !(value instanceof HTMLImageElement) ||\n          /** @type {HTMLImageElement} */ (value).complete;\n        if (imageReady && uniform.prevValue !== value) {\n          uniform.prevValue = value;\n          gl.texImage2D(\n            gl.TEXTURE_2D,\n            0,\n            gl.RGBA,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            value\n          );\n        }\n        textureSlot++;\n      } else if (Array.isArray(value) && value.length === 6) {\n        this.setUniformMatrixValue(\n          uniform.name,\n          fromTransform(this.tmpMat4_, value)\n        );\n      } else if (Array.isArray(value) && value.length <= 4) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(\n              this.getUniformLocation(uniform.name),\n              value[0],\n              value[1]\n            );\n            return;\n          case 3:\n            gl.uniform3f(\n              this.getUniformLocation(uniform.name),\n              value[0],\n              value[1],\n              value[2]\n            );\n            return;\n          case 4:\n            gl.uniform4f(\n              this.getUniformLocation(uniform.name),\n              value[0],\n              value[1],\n              value[2],\n              value[3]\n            );\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(this.getUniformLocation(uniform.name), value);\n      }\n    });\n  }\n\n  /**\n   * Set up a program for use. The program will be set as the current one. Then, the uniforms used\n   * in the program will be set based on the current frame state and the helper configuration.\n   * @param {WebGLProgram} program Program.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  useProgram(program, frameState) {\n    const gl = this.gl_;\n    gl.useProgram(program);\n    this.currentProgram_ = program;\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n\n  /**\n   * Will attempt to compile a vertex or fragment shader based on source\n   * On error, the shader will be returned but\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n   * Use `gl.getShaderInfoLog(shader)` to have details\n   * @param {string} source Shader source\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n   * @return {WebGLShader} Shader object\n   */\n  compileShader(source, type) {\n    const gl = this.gl_;\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n\n  /**\n   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n   * @param {string} fragmentShaderSource Fragment shader source.\n   * @param {string} vertexShaderSource Vertex shader source.\n   * @return {WebGLProgram} Program\n   */\n  getProgram(fragmentShaderSource, vertexShaderSource) {\n    const gl = this.gl_;\n\n    const fragmentShader = this.compileShader(\n      fragmentShaderSource,\n      gl.FRAGMENT_SHADER\n    );\n\n    const vertexShader = this.compileShader(\n      vertexShaderSource,\n      gl.VERTEX_SHADER\n    );\n\n    const program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      const message = `Fragment shader compilation failed: ${gl.getShaderInfoLog(\n        fragmentShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(fragmentShader);\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(\n        vertexShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(vertexShader);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      const message = `GL program linking failed: ${gl.getProgramInfoLog(\n        program\n      )}`;\n      throw new Error(message);\n    }\n\n    return program;\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Uniform name\n   * @return {WebGLUniformLocation} uniformLocation\n   */\n  getUniformLocation(name) {\n    const programUid = getUid(this.currentProgram_);\n    if (this.uniformLocationsByProgram_[programUid] === undefined) {\n      this.uniformLocationsByProgram_[programUid] = {};\n    }\n    if (this.uniformLocationsByProgram_[programUid][name] === undefined) {\n      this.uniformLocationsByProgram_[programUid][name] =\n        this.gl_.getUniformLocation(this.currentProgram_, name);\n    }\n    return this.uniformLocationsByProgram_[programUid][name];\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Attribute name\n   * @return {number} attribLocation\n   */\n  getAttributeLocation(name) {\n    const programUid = getUid(this.currentProgram_);\n    if (this.attribLocationsByProgram_[programUid] === undefined) {\n      this.attribLocationsByProgram_[programUid] = {};\n    }\n    if (this.attribLocationsByProgram_[programUid][name] === undefined) {\n      this.attribLocationsByProgram_[programUid][name] =\n        this.gl_.getAttribLocation(this.currentProgram_, name);\n    }\n    return this.attribLocationsByProgram_[programUid][name];\n  }\n\n  /**\n   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.\n   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../transform\").Transform} transform Transform to update.\n   * @return {import(\"../transform\").Transform} The updated transform object.\n   */\n  makeProjectionTransform(frameState, transform) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const resolution = frameState.viewState.resolution;\n    const center = frameState.viewState.center;\n    composeTransform(\n      transform,\n      0,\n      0,\n      2 / (resolution * size[0]),\n      2 / (resolution * size[1]),\n      -rotation,\n      -center[0],\n      -center[1]\n    );\n    return transform;\n  }\n\n  /**\n   * Give a value for a standard float uniform\n   * @param {string} uniform Uniform name\n   * @param {number} value Value\n   */\n  setUniformFloatValue(uniform, value) {\n    this.gl_.uniform1f(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a vec2 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n  setUniformFloatVec2(uniform, value) {\n    this.gl_.uniform2fv(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a vec4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n  setUniformFloatVec4(uniform, value) {\n    this.gl_.uniform4fv(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a standard matrix4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Matrix value\n   */\n  setUniformMatrixValue(uniform, value) {\n    this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n  }\n\n  /**\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n   * internally.\n   * @param {string} attribName Attribute name\n   * @param {number} size Number of components per attributes\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\n   * @param {number} offset Offset in bytes\n   * @private\n   */\n  enableAttributeArray_(attribName, size, type, stride, offset) {\n    const location = this.getAttributeLocation(attribName);\n    // the attribute has not been found in the shaders or is not used; do not enable it\n    if (location < 0) {\n      return;\n    }\n    this.gl_.enableVertexAttribArray(location);\n    this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);\n  }\n\n  /**\n   * Will enable the following attributes to be read from the currently bound buffer,\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n   */\n  enableAttributes(attributes) {\n    const stride = computeAttributesStride(attributes);\n    let offset = 0;\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n      this.enableAttributeArray_(\n        attr.name,\n        attr.size,\n        attr.type || FLOAT,\n        stride,\n        offset\n      );\n      offset += attr.size * getByteSizeFromType(attr.type);\n    }\n  }\n\n  /**\n   * WebGL context was lost\n   * @param {WebGLContextEvent} event The context loss event.\n   * @private\n   */\n  handleWebGLContextLost(event) {\n    clear(this.bufferCache_);\n    this.currentProgram_ = null;\n\n    event.preventDefault();\n  }\n\n  /**\n   * WebGL context was restored\n   * @private\n   */\n  handleWebGLContextRestored() {\n    this.needsToBeRecreated_ = true;\n  }\n\n  /**\n   * Returns whether this helper needs to be recreated, as the context was lost and then restored.\n   * @return {boolean} Whether this helper needs to be recreated.\n   */\n  needsToBeRecreated() {\n    return this.needsToBeRecreated_;\n  }\n\n  /**\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\n   * parameter will be ignored.\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n   * @param {Array<number>} size Expected size of the texture\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture\n   * @param {WebGLTexture} [texture] Existing texture to reuse\n   * @return {WebGLTexture} The generated texture\n   */\n  createTexture(size, data, texture) {\n    const gl = this.gl_;\n    texture = texture || gl.createTexture();\n\n    // set params & size\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    if (data) {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);\n    } else {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        size[0],\n        size[1],\n        border,\n        format,\n        type,\n        null\n      );\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    return texture;\n  }\n}\n\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n */\nexport function computeAttributesStride(attributes) {\n  let stride = 0;\n  for (let i = 0; i < attributes.length; i++) {\n    const attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\n\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\n\nexport default WebGLHelper;\n","/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (\n        !this.helper ||\n        !this.helper.canvasCacheKeyMatches(canvasCacheKey) ||\n        this.helper.needsToBeRecreated()\n      ) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1]\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n","/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {abstract, getUid} from '../../util.js';\nimport {create as createMat4} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {descending} from '../../array.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getIntersection, isEmpty} from '../../extent.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {tileIds: new Set(), representationsByZ: {}};\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(\n  tileRepresentationLookup,\n  tileRepresentation,\n  z\n) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection)\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(\n    frameState,\n    extent,\n    initialZ,\n    tileRepresentationLookup,\n    preload\n  ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0)\n        ),\n        tileSource.zDirection\n      )\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (\n            !tileRepresentation ||\n            tileRepresentation.tile.key !== tileSource.getKey()\n          ) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection\n            );\n          }\n\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter,\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            if (this.isDrawableTile_(tile)) {\n              tileRepresentation.setTile(tile);\n            } else {\n              const interimTile = /** @type {TileType} */ (\n                tile.getInterimTile()\n              );\n              tileRepresentation.setTile(interimTile);\n            }\n          }\n\n          addTileRepresentationToLookup(\n            tileRepresentationLookup,\n            tileRepresentation,\n            z\n          );\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha\n  ) {}\n\n  drawTile_(\n    frameState,\n    tileRepresentation,\n    tileZ,\n    gutter,\n    extent,\n    alphaLookup,\n    tileGrid\n  ) {\n    if (!tileRepresentation.loaded) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n    const tileScale = viewState.resolution / tileResolution;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    resetTransform(this.tileTransform_);\n    scaleTransform(\n      this.tileTransform_,\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter)\n    );\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(\n      this.tileTransform_,\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter\n    );\n\n    this.renderTile(\n      /** @type {TileRepresentation} */ (tileRepresentation),\n      this.tileTransform_,\n      frameState,\n      extent,\n      tileResolution,\n      tileSize,\n      tileOrigin,\n      tileExtent,\n      depth,\n      gutter,\n      alpha\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(\n        frameState,\n        nextExtent,\n        targetZ,\n        tileRepresentationLookup,\n        preload\n      );\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          extent,\n          z - 1,\n          tileRepresentationLookup,\n          preload - 1\n        );\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tileRepresentation of tileRepresentationLookup\n      .representationsByZ[z]) {\n      const tile = tileRepresentation.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileRepresentation.loaded) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tileRepresentationLookup\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tileRepresentationLookup\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    this.beforeTilesRender(frameState, blend);\n\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          tileZ,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid\n        );\n      }\n    }\n\n    for (const tileRepresentation of representationsByZ[z]) {\n      const tileCoord = tileRepresentation.tile.tileCoord;\n      const tileCoordKey = getTileCoordKey(tileCoord);\n      if (tileCoordKey in alphaLookup) {\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          z,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid\n        );\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (\n            tileRepresentation.loaded &&\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\n          ) {\n            addTileRepresentationToLookup(\n              tileRepresentationLookup,\n              tileRepresentation,\n              altZ\n            );\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  clearCache() {\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach((tileRepresentation) =>\n      tileRepresentation.dispose()\n    );\n    tileRepresentationCache.clear();\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\n\nexport default WebGLBaseTileLayerRenderer;\n","/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLBaseTileLayerRenderer, {\n  Uniforms as BaseUniforms,\n  getCacheKey,\n} from './TileLayerBase.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport {apply as applyTransform} from '../../transform.js';\nimport {\n  boundingExtent,\n  containsCoordinate,\n  getIntersection,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {fromTransform as mat4FromTransform} from '../../vec/mat4.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  ...BaseUniforms,\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\n};\n\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord',\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [\n  {\n    name: Attributes.TEXTURE_COORD,\n    size: 2,\n    type: AttributeType.FLOAT,\n  },\n];\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").TileType} TileTextureType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").default} TileTextureRepresentation\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, options);\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset(options);\n\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(\n        this.fragmentShader_,\n        this.vertexShader_\n      );\n    }\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n    this.helper.flushBufferData(this.indices_);\n  }\n\n  createTileRepresentation(options) {\n    return new TileTexture(options);\n  }\n\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    super.beforeTilesRender(frameState, tilesWithAlpha);\n    this.helper.useProgram(this.program_, frameState);\n  }\n\n  renderTile(\n    tileTexture,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha\n  ) {\n    const gl = this.helper.getGL();\n    this.helper.bindBuffer(tileTexture.coords);\n    this.helper.bindBuffer(this.indices_);\n    this.helper.enableAttributes(attributeDescriptions);\n\n    let textureSlot = 0;\n    while (textureSlot < tileTexture.textures.length) {\n      const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n      this.helper.bindTexture(\n        tileTexture.textures[textureSlot],\n        textureSlot,\n        uniformName\n      );\n      ++textureSlot;\n    }\n\n    for (\n      let paletteIndex = 0;\n      paletteIndex < this.paletteTextures_.length;\n      ++paletteIndex\n    ) {\n      const paletteTexture = this.paletteTextures_[paletteIndex];\n      const texture = paletteTexture.getTexture(gl);\n      this.helper.bindTexture(texture, textureSlot, paletteTexture.name);\n      ++textureSlot;\n    }\n\n    const viewState = frameState.viewState;\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const tile = tileTexture.tile;\n    const tileCoord = tile.tileCoord;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    this.helper.setUniformMatrixValue(\n      Uniforms.TILE_TRANSFORM,\n      mat4FromTransform(this.tempMat4, tileTransform)\n    );\n\n    this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n    this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n\n    let gutterExtent = renderExtent;\n    if (gutter > 0) {\n      gutterExtent = tileExtent;\n      getIntersection(gutterExtent, renderExtent, gutterExtent);\n    }\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n\n    this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n    this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_WIDTH,\n      tileWidthWithGutter\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_HEIGHT,\n      tileHeightWithGutter\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_RESOLUTION,\n      tileResolution\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_X,\n      tileOrigin[0] +\n        tileCenterI * tileSize[0] * tileResolution -\n        gutter * tileResolution\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_Y,\n      tileOrigin[1] -\n        tileCenterJ * tileSize[1] * tileResolution +\n        gutter * tileResolution\n    );\n\n    this.helper.drawElements(0, this.indices_.getSize());\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (\n        !containsCoordinate(\n          fromUserExtent(layerExtent, viewState.projection),\n          coordinate\n        )\n      ) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(\n      boundingExtent([coordinate]),\n      viewState.resolution\n    );\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n\n    const tileTextureCache = this.tileRepresentationCache;\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      const tile = tileTexture.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        return null;\n      }\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col =\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\n        tileCoord[1] * tileSize[0];\n\n      const row =\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\n        tileCoord[2] * tileSize[1];\n\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n    super.disposeInternal();\n    delete this.indices_;\n  }\n}\n\nexport default WebGLTileLayerRenderer;\n","/**\n * @module ol/webgl/PaletteTexture\n */\n\nclass PaletteTexture {\n  /**\n   * @param {string} name The name of the texture.\n   * @param {Uint8Array} data The texture data.\n   */\n  constructor(name, data) {\n    this.name = name;\n    this.data = data;\n\n    /**\n     * @type {WebGLTexture}\n     * @private\n     */\n    this.texture_ = null;\n  }\n\n  /**\n   * @param {WebGLRenderingContext} gl Rendering context.\n   * @return {WebGLTexture} The texture.\n   */\n  getTexture(gl) {\n    if (!this.texture_) {\n      const texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        this.data.length / 4,\n        1,\n        0,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        this.data\n      );\n      this.texture_ = texture;\n    }\n    return this.texture_;\n  }\n}\n\nexport default PaletteTexture;\n","/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray, fromString, isStringColor} from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0,\n};\n\n/**\n * @param {string} typeHint Type hint\n * @return {ValueTypes} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return ValueTypes.STRING;\n    case 'color':\n      return ValueTypes.COLOR;\n    case 'number':\n      return ValueTypes.NUMBER;\n    case 'boolean':\n      return ValueTypes.BOOLEAN;\n    case 'number[]':\n      return ValueTypes.NUMBER_ARRAY;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes): string} toGlsl Returns a GLSL-compatible string\n * given a parsing context, an array of arguments and an expected type.\n * Note: the expected type can be a combination such as ValueTypes.NUMBER | ValueTypes.STRING or ValueTypes.ANY for instance\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */ (value);\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\n      `Expected an expression operator but received: ${JSON.stringify(\n        valueArr\n      )}`\n    );\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\n      `Unrecognized expression operator: ${JSON.stringify(valueArr)}`\n    );\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Print types as a readable string\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {string} Types\n */\nfunction printTypes(valueType) {\n  const result = [];\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    result.push('number');\n  }\n  if ((valueType & ValueTypes.COLOR) > 0) {\n    result.push('color');\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    result.push('boolean');\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    result.push('number[]');\n  }\n  if ((valueType & ValueTypes.STRING) > 0) {\n    result.push('string');\n  }\n  return result.length > 0 ? result.join(', ') : '(no type)';\n}\n\n/**\n * @typedef {Object} ParsingContextExternal\n * @property {string} name Name, unprefixed\n * @property {ValueTypes} type One of the value types constants\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [callback] Function used for computing the attribute value;\n *   if undefined, `feature.get(attribute.name)` will be used\n */\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<ParsingContextExternal>} variables External variables used in the expression\n * @property {Array<ParsingContextExternal>} attributes External attributes used in the expression\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/literal\").LiteralStyle} style The style being parsed\n */\n\n/**\n * @param {string} operator Operator\n * @param {ParsingContext} context Parsing context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([\n    (array[0] / 255) * alpha,\n    (array[1] / 255) * alpha,\n    (array[2] / 255) * alpha,\n    alpha,\n  ]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [expectedType] Expected final type (can be several types combined)\n * If omitted, defaults to ValueTypes.NUMBER\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, expectedType) {\n  const returnType =\n    expectedType !== undefined ? expectedType : ValueTypes.NUMBER;\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\n        `Unrecognized expression operator: ${JSON.stringify(value)}`\n      );\n    }\n    return operator.toGlsl(context, value.slice(1), returnType);\n  }\n\n  const possibleType = getValueType(value) & returnType;\n  assertNotEmptyType(value, possibleType, '');\n\n  if ((possibleType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */ (value));\n  }\n\n  if ((possibleType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n\n  if ((possibleType & ValueTypes.STRING) > 0) {\n    return stringToGlsl(value.toString());\n  }\n\n  if ((possibleType & ValueTypes.COLOR) > 0) {\n    return colorToGlsl(/** @type {Array<number> | string} */ (value));\n  }\n\n  if ((possibleType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (value));\n  }\n\n  throw new Error(\n    `Unexpected expression ${value} (expected type ${printTypes(returnType)})`\n  );\n}\n\nfunction assertNumber(value) {\n  if ((getValueType(value) & ValueTypes.NUMBER) === 0) {\n    throw new Error(\n      `A numeric value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if ((getValueType(value) & ValueTypes.STRING) === 0) {\n    throw new Error(\n      `A string value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertBoolean(value) {\n  if ((getValueType(value) & ValueTypes.BOOLEAN) === 0) {\n    throw new Error(\n      `A boolean value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\n      `Exactly ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\n      `At least ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\n      `At most ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\n      `An even amount of arguments was expected, got ${JSON.stringify(\n        args\n      )} instead`\n    );\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected, got ${JSON.stringify(\n        args\n      )} instead`\n    );\n  }\n}\nfunction assertNotEmptyType(args, types, descriptor) {\n  if (types === ValueTypes.NONE) {\n    throw new Error(\n      `No matching type was found for the following expression ${descriptor}: ${JSON.stringify(\n        args\n      )}`\n    );\n  }\n}\nfunction assertSingleType(args, types, descriptor) {\n  assertNotEmptyType(args, types, descriptor);\n  if (!isTypeUnique(types)) {\n    throw new Error(\n      `Expected to have a unique type for the following expression ${descriptor}: ${JSON.stringify(\n        args\n      )}\nGot the following types instead: ${printTypes(types)}`\n    );\n  }\n}\nfunction assertOfType(args, types, expectedTypes, descriptor) {\n  if ((types & expectedTypes) === ValueTypes.NONE) {\n    throw new Error(\n      `Expected the ${descriptor} type of the following expression: ${JSON.stringify(\n        args\n      )} to be of the following types: ${printTypes(expectedTypes)}\nGot these types instead: ${printTypes(types)}`\n    );\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    if (args.length === 2) {\n      const hint = args[1];\n      return getTypeFromHint(/** @type {string} */ (hint));\n    }\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertString(args[0]);\n    const outputType = expectedType & Operators['get'].getReturnType(args);\n    assertSingleType(['get', ...args], outputType, '');\n    const name = args[0].toString();\n    const existing = context.attributes.find((a) => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: outputType,\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(\n        `The following attribute was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`\n      );\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  },\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\nOperators['var'] = {\n  getReturnType: function () {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const name = args[0].toString();\n    if (\n      !context.style.variables ||\n      context.style.variables[name] === undefined\n    ) {\n      throw new Error(\n        `The following variable is missing from the style: ${name}`\n      );\n    }\n    const initialValue = context.style.variables[name];\n    const outputType = expectedType & getValueType(initialValue);\n    assertSingleType(['var', ...args], outputType, '');\n    const existing = context.variables.find((a) => a.name === name);\n    if (!existing) {\n      context.variables.push({\n        name: name,\n        type: outputType,\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(\n        `The following variable was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`\n      );\n    }\n    return uniformNameForVariable(name);\n  },\n};\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error(\n            'The second argument of palette must be an array of strings or colors'\n          );\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(\n              `Expected palette color to have 3 or 4 values, got ${length}`\n            );\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n};\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nOperators['band'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  },\n};\n\nOperators['time'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  },\n};\n\nOperators['zoom'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  },\n};\n\nOperators['resolution'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  },\n};\n\nOperators['geometry-type'] = {\n  getReturnType: function () {\n    return ValueTypes.STRING;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    const name = 'geometryType';\n    const computeType = (geometry) => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const existing = context.attributes.find((a) => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: ValueTypes.STRING,\n        callback: (feature) => {\n          return computeType(feature.getGeometry());\n        },\n      });\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  },\n};\n\nOperators['*'] = {\n  getReturnType: function (args) {\n    let outputType = ValueTypes.NUMBER | ValueTypes.COLOR;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    return outputType;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 2);\n    let outputType = expectedType;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    assertOfType(\n      args,\n      outputType,\n      ValueTypes.NUMBER | ValueTypes.COLOR,\n      'output'\n    );\n    return `(${args\n      .map((arg) => expressionToGlsl(context, arg, outputType))\n      .join(' * ')})`;\n  },\n};\n\nOperators['/'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['+'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertNumbers(args);\n    return `(${args.map((arg) => expressionToGlsl(context, arg)).join(' + ')})`;\n  },\n};\n\nOperators['-'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['clamp'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  },\n};\n\nOperators['%'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['^'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['abs'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['floor'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['round'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  },\n};\n\nOperators['ceil'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sin'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['cos'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['atan'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2\n      ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n          context,\n          args[1]\n        )})`\n      : `atan(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sqrt'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sqrt(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['>'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['>='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(\n          `All arguments should be of compatible type, got ${JSON.stringify(\n            args\n          )} instead`\n        );\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n\n      return `(${expressionToGlsl(\n        context,\n        args[0],\n        type\n      )} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    },\n  };\n}\n\nOperators['=='] = getEqualOperator('==');\n\nOperators['!='] = getEqualOperator('!=');\n\nOperators['!'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0], ValueTypes.BOOLEAN)})`;\n  },\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = args\n        .map((arg) => expressionToGlsl(context, arg, ValueTypes.BOOLEAN))\n        .join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    },\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\n\nOperators['any'] = getDecisionOperator('||');\n\nOperators['between'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  },\n};\n\nOperators['array'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['color'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args\n      .slice(0, 3)\n      .map((val) => `${expressionToGlsl(context, val)} / 255.0`);\n    if (args.length === 3) {\n      return `vec4(${parsedArgs.join(', ')}, 1.0)`;\n    }\n    const alpha = expressionToGlsl(context, args[3]);\n    return `(${alpha} * vec4(${parsedArgs.join(', ')}, 1.0))`;\n  },\n};\n\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\n        `Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(\n          type\n        )}`\n      );\n    }\n\n    // compute input/output types\n    const inputType = ValueTypes.NUMBER;\n    const outputType =\n      Operators['interpolate'].getReturnType(args) & expectedType;\n    assertSingleType(['interpolate', ...args], outputType, 'output');\n\n    const input = expressionToGlsl(context, args[1], inputType);\n    const exponent = numberToGlsl(interpolation);\n\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i], inputType);\n      const output1 =\n        result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2], inputType);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      let ratio;\n      if (interpolation === 1) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  },\n};\n\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n\n    let inputType = getValueType(args[0]);\n    for (let i = 1; i < args.length - 1; i += 2) {\n      inputType = inputType & getValueType(args[i]);\n    }\n    assertOfType(\n      ['match', ...args],\n      inputType,\n      ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN,\n      'input'\n    );\n    inputType =\n      (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n\n    const outputType = Operators['match'].getReturnType(args) & expectedType;\n    assertSingleType(['match', ...args], outputType, 'output');\n\n    const input = expressionToGlsl(context, args[0], inputType);\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i], inputType);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n\n    const outputType = Operators['case'].getReturnType(args) & expectedType;\n    assertSingleType(['case', ...args], outputType, 'output');\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i], ValueTypes.BOOLEAN);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['in'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    const needle = args[0];\n    let haystack = args[1];\n    if (!Array.isArray(haystack)) {\n      throw new Error(\n        `The \"in\" operator expects an array literal as its second argument.`\n      );\n    }\n    if (typeof haystack[0] === 'string') {\n      if (haystack[0] !== 'literal') {\n        throw new Error(\n          `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`\n        );\n      }\n      if (!Array.isArray(haystack[1])) {\n        throw new Error(\n          `The \"in\" operator was provided a literal value which was not an array as second argument.`\n        );\n      }\n      haystack = haystack[1];\n    }\n\n    let inputType = getValueType(needle);\n    for (let i = 0; i < haystack.length - 1; i += 1) {\n      inputType = inputType & getValueType(haystack[i]);\n    }\n    assertOfType(\n      ['match', ...args],\n      inputType,\n      ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN,\n      'input'\n    );\n    inputType =\n      (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(\n        `  if (inputValue == ${expressionToGlsl(\n          context,\n          haystack[i],\n          inputType\n        )}) { return true; }`\n      );\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${expressionToGlsl(context, needle, inputType)})`;\n  },\n};\n","/**\n * @module ol/layer/WebGLTile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport LayerProperty from '../layer/Property.js';\nimport WebGLTileLayerRenderer, {\n  Attributes,\n  Uniforms,\n} from '../renderer/webgl/TileLayer.js';\nimport {\n  PALETTE_TEXTURE_ARRAY,\n  ValueTypes,\n  expressionToGlsl,\n  getStringNumberEquivalent,\n  uniformNameForVariable,\n} from '../style/expressions.js';\n\n/**\n * @typedef {import(\"../source/DataTile.js\").default|import(\"../source/TileImage.js\").default} SourceType\n */\n\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\n * {@link import(\"../style/expressions.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [color] An expression applied to color values.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\n * the layer brightness.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\n * the layer contrast.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\n * the layer exposure.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\n * the layer saturation.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\n * Values range from 0 to infinity.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {SourceType} [source] Source for this layer.\n * @property {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>} [sources] Array\n * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that\n * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See\n * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a\n * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map~Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} vertexShader The vertex shader.\n * @property {string} fragmentShader The fragment shader.\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../webgl/PaletteTexture.js\").default>} paletteTextures Palette textures.\n */\n\n/**\n * @param {Style} style The layer style.\n * @param {number} [bandCount] The number of bands.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\nfunction parseStyle(style, bandCount) {\n  const vertexShader = `\n    attribute vec2 ${Attributes.TEXTURE_COORD};\n    uniform mat4 ${Uniforms.TILE_TRANSFORM};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.TEXTURE_RESOLUTION};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_X};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};\n    uniform float ${Uniforms.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${Attributes.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);\n    }\n  `;\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const context = {\n    inFragmentShader: true,\n    variables: [],\n    attributes: [],\n    functions: {},\n    bandCount: bandCount,\n    style: style,\n  };\n\n  const pipeline = [];\n\n  if (style.color !== undefined) {\n    const color = expressionToGlsl(context, style.color, ValueTypes.COLOR);\n    pipeline.push(`color = ${color};`);\n  }\n\n  if (style.contrast !== undefined) {\n    const contrast = expressionToGlsl(\n      context,\n      style.contrast,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(\n      `color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`\n    );\n  }\n\n  if (style.exposure !== undefined) {\n    const exposure = expressionToGlsl(\n      context,\n      style.exposure,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(\n      `color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`\n    );\n  }\n\n  if (style.saturation !== undefined) {\n    const saturation = expressionToGlsl(\n      context,\n      style.saturation,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(`\n      float saturation = ${saturation} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `);\n  }\n\n  if (style.gamma !== undefined) {\n    const gamma = expressionToGlsl(context, style.gamma, ValueTypes.NUMBER);\n    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);\n  }\n\n  if (style.brightness !== undefined) {\n    const brightness = expressionToGlsl(\n      context,\n      style.brightness,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(\n      `color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`\n    );\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  const numVariables = context.variables.length;\n  if (numVariables > 1 && !style.variables) {\n    throw new Error(\n      `Missing variables in style (expected ${context.variables})`\n    );\n  }\n\n  for (let i = 0; i < numVariables; ++i) {\n    const variable = context.variables[i];\n    if (!(variable.name in style.variables)) {\n      throw new Error(`Missing '${variable.name}' in style variables`);\n    }\n    const uniformName = uniformNameForVariable(variable.name);\n    uniforms[uniformName] = function () {\n      let value = style.variables[variable.name];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  }\n\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return `uniform float ${name};`;\n  });\n\n  const textureCount = Math.ceil(bandCount / 4);\n  uniformDeclarations.push(\n    `uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`\n  );\n\n  if (context.paletteTextures) {\n    uniformDeclarations.push(\n      `uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}];`\n    );\n  }\n\n  const functionDefintions = Object.keys(context.functions).map(function (\n    name\n  ) {\n    return context.functions[name];\n  });\n\n  const fragmentShader = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${Uniforms.RENDER_EXTENT};\n    uniform float ${Uniforms.TRANSITION_ALPHA};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.RESOLUTION};\n    uniform float ${Uniforms.ZOOM};\n\n    ${uniformDeclarations.join('\\n')}\n\n    ${functionDefintions.join('\\n')}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||\n        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||\n        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||\n        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${\n        Uniforms.TILE_TEXTURE_ARRAY\n      }[0],  v_textureCoord);\n\n      ${pipeline.join('\\n')}\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};\n    }`;\n\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    uniforms: uniforms,\n    paletteTextures: context.paletteTextures,\n  };\n}\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\nclass WebGLTileLayer extends BaseTileLayer {\n  /**\n   * @param {Options} options Tile layer options.\n   */\n  constructor(options) {\n    options = options ? Object.assign({}, options) : {};\n\n    const style = options.style || {};\n    delete options.style;\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    super(options);\n\n    /**\n     * @type {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>}\n     * @private\n     */\n    this.sources_ = options.sources;\n\n    /**\n     * @type {SourceType|null}\n     * @private\n     */\n    this.renderedSource_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.style_ = style;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    /**\n     * @type {Object<string, (string|number)>}\n     * @private\n     */\n    this.styleVariables_ = this.style_.variables || {};\n\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\n  }\n\n  /**\n   * Gets the sources for this layer, for a given extent and resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<SourceType>} Sources.\n   */\n  getSources(extent, resolution) {\n    const source = this.getSource();\n    return this.sources_\n      ? typeof this.sources_ === 'function'\n        ? this.sources_(extent, resolution)\n        : this.sources_\n      : source\n      ? [source]\n      : [];\n  }\n\n  /**\n   * @return {SourceType} The source being rendered.\n   */\n  getRenderSource() {\n    return this.renderedSource_ || this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    const source = this.getRenderSource();\n    return source ? source.getState() : 'undefined';\n  }\n\n  /**\n   * @private\n   */\n  handleSourceUpdate_() {\n    if (this.hasRenderer()) {\n      this.getRenderer().clearCache();\n    }\n    if (this.getSource()) {\n      this.setStyle(this.style_);\n    }\n  }\n\n  /**\n   * @private\n   * @return {number} The number of source bands.\n   */\n  getSourceBandCount_() {\n    const max = Number.MAX_SAFE_INTEGER;\n    const sources = this.getSources([-max, -max, max, max], max);\n    return sources && sources.length && 'bandCount' in sources[0]\n      ? sources[0].bandCount\n      : 4;\n  }\n\n  createRenderer() {\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n\n    return new WebGLTileLayerRenderer(this, {\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      cacheSize: this.cacheSize_,\n      paletteTextures: parsedStyle.paletteTextures,\n    });\n  }\n\n  /**\n   * @param {import(\"../Map\").FrameState} frameState Frame state.\n   * @param {Array<SourceType>} sources Sources.\n   * @return {HTMLElement} Canvas.\n   */\n  renderSources(frameState, sources) {\n    const layerRenderer = this.getRenderer();\n    let canvas;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      this.renderedSource_ = sources[i];\n      if (layerRenderer.prepareFrame(frameState)) {\n        canvas = layerRenderer.renderFrame(frameState);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n  render(frameState, target) {\n    this.rendered = true;\n    const viewState = frameState.viewState;\n    const sources = this.getSources(frameState.extent, viewState.resolution);\n    let ready = true;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      const source = sources[i];\n      const sourceState = source.getState();\n      if (sourceState == 'loading') {\n        const onChange = () => {\n          if (source.getState() == 'ready') {\n            source.removeEventListener('change', onChange);\n            this.changed();\n          }\n        };\n        source.addEventListener('change', onChange);\n      }\n      ready = ready && sourceState == 'ready';\n    }\n    const canvas = this.renderSources(frameState, sources);\n    if (this.getRenderer().renderComplete && ready) {\n      // Fully rendered, done.\n      this.renderedResolution_ = viewState.resolution;\n      return canvas;\n    }\n    // Render sources from previously fully rendered frames\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\n      const altSources = this.getSources(\n        frameState.extent,\n        this.renderedResolution_\n      ).filter((source) => !sources.includes(source));\n      if (altSources.length > 0) {\n        return this.renderSources(frameState, altSources);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * Update the layer style.  The `updateStyleVariables` function is a more efficient\n   * way to update layer rendering.  In cases where the whole style needs to be updated,\n   * this method may be called instead.  Note that calling this method will also replace\n   * any previously set variables, so the new style also needs to include new variables,\n   * if needed.\n   * @param {Style} style The new style.\n   */\n  setStyle(style) {\n    this.styleVariables_ = style.variables || {};\n    this.style_ = style;\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n    const renderer = this.getRenderer();\n    renderer.reset({\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   * @api\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n}\n\n/**\n * Clean up underlying WebGL resources.\n * @function\n * @api\n */\nWebGLTileLayer.prototype.dispose;\n\nexport default WebGLTileLayer;\n","/**\n * @module ol/math\n */\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\nexport function clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n  return squaredDistance(x, y, x1, y1);\n}\n\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredDistance(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>} The resulting vector.\n */\nexport function solveLinearSystem(mat) {\n  const n = mat.length;\n\n  for (let i = 0; i < n; i++) {\n    // Find max in the i-th column (ignoring i - 1 first rows)\n    let maxRow = i;\n    let maxEl = Math.abs(mat[i][i]);\n    for (let r = i + 1; r < n; r++) {\n      const absValue = Math.abs(mat[r][i]);\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r;\n      }\n    }\n\n    if (maxEl === 0) {\n      return null; // matrix is singular\n    }\n\n    // Swap max row with i-th (current) row\n    const tmp = mat[maxRow];\n    mat[maxRow] = mat[i];\n    mat[i] = tmp;\n\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n    for (let j = i + 1; j < n; j++) {\n      const coef = -mat[j][i] / mat[i][i];\n      for (let k = i; k < n + 1; k++) {\n        if (i == k) {\n          mat[j][k] = 0;\n        } else {\n          mat[j][k] += coef * mat[i][k];\n        }\n      }\n    }\n  }\n\n  // Solve Ax=b for upper triangular matrix A (mat)\n  const x = new Array(n);\n  for (let l = n - 1; l >= 0; l--) {\n    x[l] = mat[l][n] / mat[l][l];\n    for (let m = l - 1; m >= 0; m--) {\n      mat[m][n] -= mat[m][l] * x[l];\n    }\n  }\n  return x;\n}\n\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\nexport function toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\nexport function toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\nexport function modulo(a, b) {\n  const r = a % b;\n  return r * b < 0 ? r + b : r;\n}\n\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\nexport function lerp(a, b, x) {\n  return a + x * (b - a);\n}\n\n/**\n * Returns a number with a limited number of decimal digits.\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The input number with a limited number of decimal digits.\n */\nexport function toFixed(n, decimals) {\n  const factor = Math.pow(10, decimals);\n  return Math.round(n * factor) / factor;\n}\n\n/**\n * Rounds a number to the nearest integer value considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The nearest integer.\n */\nexport function round(n, decimals) {\n  return Math.round(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next smaller integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next smaller integer.\n */\nexport function floor(n, decimals) {\n  return Math.floor(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next bigger integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next bigger integer.\n */\nexport function ceil(n, decimals) {\n  return Math.ceil(toFixed(n, decimals));\n}\n","/**\n * @module ol/obj\n */\n\n/**\n * Removes all properties from an object.\n * @param {Object} object The object to clear.\n */\nexport function clear(object) {\n  for (const property in object) {\n    delete object[property];\n  }\n}\n\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */\nexport function isEmpty(object) {\n  let property;\n  for (property in object) {\n    return false;\n  }\n  return !property;\n}\n","/**\n * @module ol/proj/Units\n */\n\n/**\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\n * Projection units.\n */\n\n/**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */\nconst unitByCode = {\n  '9001': 'm',\n  '9002': 'ft',\n  '9003': 'us-ft',\n  '9101': 'radians',\n  '9102': 'degrees',\n};\n\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */\nexport function fromCode(code) {\n  return unitByCode[code];\n}\n\n/**\n * @typedef {Object} MetersPerUnitLookup\n * @property {number} radians Radians\n * @property {number} degrees Degrees\n * @property {number} ft  Feet\n * @property {number} m Meters\n * @property {number} us-ft US feet\n */\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {MetersPerUnitLookup}\n * @api\n */\nexport const METERS_PER_UNIT = {\n  // use the radius of the Normal sphere\n  'radians': 6370997 / (2 * Math.PI),\n  'degrees': (2 * Math.PI * 6370997) / 360,\n  'ft': 0.3048,\n  'm': 1,\n  'us-ft': 1200 / 3937,\n};\n","/**\n * @module ol/proj/Projection\n */\nimport {METERS_PER_UNIT} from './Units.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution} function will be used.\n */\n\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4.register} function.\n *\n * @api\n */\nclass Projection {\n  /**\n   * @param {Options} options Projection options.\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n\n    /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import(\"./Units.js\").Units}\n     */\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\n\n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n\n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.worldExtent_ =\n      options.worldExtent !== undefined ? options.worldExtent : null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ =\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n\n    /**\n     * @private\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.defaultTileGrid_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n\n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  canWrapX() {\n    return this.canWrapX_;\n  }\n\n  /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */\n  getCode() {\n    return this.code_;\n  }\n\n  /**\n   * Get the validity extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the units of this projection.\n   * @return {import(\"./Units.js\").Units} Units.\n   * @api\n   */\n  getUnits() {\n    return this.units_;\n  }\n\n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  getMetersPerUnit() {\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n  }\n\n  /**\n   * Get the world extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getWorldExtent() {\n    return this.worldExtent_;\n  }\n\n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  getAxisOrientation() {\n    return this.axisOrientation_;\n  }\n\n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  isGlobal() {\n    return this.global_;\n  }\n\n  /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */\n  setGlobal(global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  }\n\n  /**\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n   */\n  getDefaultTileGrid() {\n    return this.defaultTileGrid_;\n  }\n\n  /**\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n   */\n  setDefaultTileGrid(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  }\n\n  /**\n   * Set the validity extent for this projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  setExtent(extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  }\n\n  /**\n   * Set the world extent for this projection.\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  setWorldExtent(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  }\n\n  /**\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n   * for this projection.\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n   * @api\n   */\n  setGetPointResolution(func) {\n    this.getPointResolutionFunc_ = func;\n  }\n\n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */\n  getPointResolutionFunc() {\n    return this.getPointResolutionFunc_;\n  }\n}\n\nexport default Projection;\n","/**\n * @module ol/proj/epsg3857\n */\nimport Projection from './Projection.js';\n\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * @const\n * @type {number}\n */\nexport const HALF_SIZE = Math.PI * RADIUS;\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\n\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nclass EPSG3857Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   */\n  constructor(code) {\n    super({\n      code: code,\n      units: 'm',\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function (resolution, point) {\n        return resolution / Math.cosh(point[1] / RADIUS);\n      },\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG3857Projection('EPSG:3857'),\n  new EPSG3857Projection('EPSG:102100'),\n  new EPSG3857Projection('EPSG:102113'),\n  new EPSG3857Projection('EPSG:900913'),\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\n];\n\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function fromEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (HALF_SIZE * input[i]) / 180;\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\n    if (y > MAX_SAFE_Y) {\n      y = MAX_SAFE_Y;\n    } else if (y < -MAX_SAFE_Y) {\n      y = -MAX_SAFE_Y;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n}\n\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function toEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (180 * input[i]) / HALF_SIZE;\n    output[i + 1] =\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\n  }\n  return output;\n}\n","/**\n * @module ol/proj/epsg4326\n */\nimport Projection from './Projection.js';\n\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-180, -90, 180, 90];\n\n/**\n * @const\n * @type {number}\n */\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\n\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nclass EPSG4326Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   * @param {string} [axisOrientation] Axis orientation.\n   */\n  constructor(code, axisOrientation) {\n    super({\n      code: code,\n      units: 'degrees',\n      extent: EXTENT,\n      axisOrientation: axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: EXTENT,\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG4326Projection('CRS:84'),\n  new EPSG4326Projection('EPSG:4326', 'neu'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\n];\n","/**\n * @module ol/proj/projections\n */\n\n/**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */\nlet cache = {};\n\n/**\n * Clear the projections cache.\n */\nexport function clear() {\n  cache = {};\n}\n\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default} The projection (if cached).\n */\nexport function get(code) {\n  return (\n    cache[code] ||\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\n    null\n  );\n}\n\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */\nexport function add(code, projection) {\n  cache[code] = projection;\n}\n","/**\n * @module ol/proj/transforms\n */\nimport {isEmpty} from '../obj.js';\n\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nlet transforms = {};\n\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  const transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  let transform;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n}\n","/**\n * @module ol/sphere\n */\nimport {toDegrees, toRadians} from './math.js';\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport const DEFAULT_RADIUS = 6371008.8;\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lat2 = toRadians(c2[1]);\n  const deltaLatBy2 = (lat2 - lat1) / 2;\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  const a =\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n    Math.sin(deltaLonBy2) *\n      Math.sin(deltaLonBy2) *\n      Math.cos(lat1) *\n      Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  let length = 0;\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let length = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint': {\n      break;\n    }\n    case 'LineString':\n    case 'LinearRing': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      length = getLengthInternal(coordinates, radius);\n      break;\n    }\n    case 'MultiLineString':\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += getLengthInternal(coordinates[i], radius);\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += getLengthInternal(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += getLength(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n}\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area +=\n      toRadians(x2 - x1) *\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return (area * radius * radius) / 2.0;\n}\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let area = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'LinearRing': {\n      break;\n    }\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(getAreaInternal(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(getAreaInternal(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += getArea(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n}\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lon1 = toRadians(c1[0]);\n  const dByR = distance / radius;\n  const lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n  );\n  const lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n","/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport {\n  PROJECTIONS as EPSG3857_PROJECTIONS,\n  fromEPSG4326,\n  toEPSG4326,\n} from './proj/epsg3857.js';\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\nimport {METERS_PER_UNIT} from './proj/Units.js';\nimport {\n  add as addProj,\n  clear as clearProj,\n  get as getProj,\n} from './proj/projections.js';\nimport {\n  add as addTransformFunc,\n  clear as clearTransformFuncs,\n  get as getTransformFunc,\n} from './proj/transforms.js';\nimport {applyTransform, getWidth} from './extent.js';\nimport {clamp, modulo} from './math.js';\nimport {equals, getWorldsAway} from './coordinate.js';\nimport {getDistance} from './sphere.js';\nimport {warn} from './console.js';\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\nexport {METERS_PER_UNIT};\n\nexport {Projection};\n\nlet showCoordinateWarning = true;\n\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */\nexport function disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, output) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    output = output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, output) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    input = output;\n  }\n  return input;\n}\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n  return typeof projectionLike === 'string'\n    ? getProj(/** @type {string} */ (projectionLike))\n    : /** @type {Projection} */ (projectionLike) || null;\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution =\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(\n        projection,\n        get('EPSG:4326')\n      );\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2,\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      const metersPerUnit = units\n        ? METERS_PER_UNIT[units]\n        : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(\n  projections1,\n  projections2,\n  forwardTransform,\n  inverseTransform\n) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  }\n  if (typeof projection === 'string') {\n    return get(projection);\n  }\n  return /** @type {Projection} */ (projection);\n}\n\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      output = output !== undefined ? output : new Array(length);\n      for (let i = 0; i < length; i += dimension) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n        for (let j = 0, jj = dimension; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n      return output;\n    }\n  );\n}\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(\n    sourceProj,\n    destProj,\n    createTransformFromCoordinateTransform(forward)\n  );\n  addTransformFunc(\n    destProj,\n    sourceProj,\n    createTransformFromCoordinateTransform(inverse)\n  );\n}\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(\n    coordinate,\n    'EPSG:4326',\n    projection !== undefined ? projection : 'EPSG:3857'\n  );\n}\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, projection) {\n  const lonLat = transform(\n    coordinate,\n    projection !== undefined ? projection : 'EPSG:3857',\n    'EPSG:4326'\n  );\n  const lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  }\n  const transformFunc = getTransformFromProjections(projection1, projection2);\n  return transformFunc === cloneTransform && equalUnits;\n}\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nexport function getTransformFromProjections(\n  sourceProjection,\n  destinationProjection\n) {\n  const sourceCode = sourceProjection.getCode();\n  const destinationCode = destinationProjection.getCode();\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, stops);\n}\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(\n  point,\n  sourceProjection,\n  destinationProjection\n) {\n  const transformFunc = getTransformFromProjections(\n    sourceProjection,\n    destinationProjection\n  );\n  return transformFunc(point);\n}\n\n/**\n * @type {Projection|null}\n */\nlet userProjection = null;\n\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n\n/**\n * Clear the user projection if set.\n * @api\n */\nexport function clearUserProjection() {\n  userProjection = null;\n}\n\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nexport function getUserProjection() {\n  return userProjection;\n}\n\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @api\n */\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (\n      showCoordinateWarning &&\n      !equals(coordinate, [0, 0]) &&\n      coordinate[0] >= -180 &&\n      coordinate[0] <= 180 &&\n      coordinate[1] >= -90 &&\n      coordinate[1] <= 90\n    ) {\n      showCoordinateWarning = false;\n      warn(\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.'\n      );\n    }\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nexport function toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(sourceProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[sourceUnits]) / METERS_PER_UNIT[userUnits]\n    : resolution;\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nexport function fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(destProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[userUnits]) / METERS_PER_UNIT[sourceUnits]\n    : resolution;\n}\n\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destination).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destination).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(\n    EPSG4326_PROJECTIONS,\n    EPSG3857_PROJECTIONS,\n    fromEPSG4326,\n    toEPSG4326\n  );\n}\n\naddCommon();\n","/**\n * @module ol/render/Event\n */\n\nimport Event from '../events/Event.js';\n\nclass RenderEvent extends Event {\n  /**\n   * @param {import(\"./EventType.js\").default} type Type.\n   * @param {import(\"../transform.js\").Transform} [inversePixelTransform] Transform for\n   *     CSS pixels to rendered pixels.\n   * @param {import(\"../Map.js\").FrameState} [frameState] Frame state.\n   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.\n   */\n  constructor(type, inversePixelTransform, frameState, context) {\n    super(type);\n\n    /**\n     * Transform from CSS pixels (relative to the top-left corner of the map viewport)\n     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.\n     * @type {import(\"../transform.js\").Transform|undefined}\n     * @api\n     */\n    this.inversePixelTransform = inversePixelTransform;\n\n    /**\n     * An object representing the current render frame state.\n     * @type {import(\"../Map.js\").FrameState|undefined}\n     * @api\n     */\n    this.frameState = frameState;\n\n    /**\n     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,\n     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL\n     * context.\n     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}\n     * @api\n     */\n    this.context = context;\n  }\n}\n\nexport default RenderEvent;\n","/**\n * @module ol/render/EventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered before a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#prerender\n   * @api\n   */\n  PRERENDER: 'prerender',\n\n  /**\n   * Triggered after a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#postrender\n   * @api\n   */\n  POSTRENDER: 'postrender',\n\n  /**\n   * Triggered before layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#precompose\n   * @api\n   */\n  PRECOMPOSE: 'precompose',\n\n  /**\n   * Triggered after layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#postcompose\n   * @api\n   */\n  POSTCOMPOSE: 'postcompose',\n\n  /**\n   * Triggered when rendering is complete, i.e. all sources and tiles have\n   * finished loading for the current viewport, and all tiles are faded in.\n   * The event object will not have a `context` set.\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\n   * @api\n   */\n  RENDERCOMPLETE: 'rendercomplete',\n};\n\n/**\n * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes\n */\n\n/**\n * @typedef {'postrender'|'prerender'} LayerRenderEventTypes\n */\n","/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      (zoom, tileRange) => {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (\n      image.getState() === ImageState.LOADED ||\n      image.getState() === ImageState.ERROR\n    ) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../Image.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n","/**\n * @module ol/reproj\n */\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\n  const stitchContext = createCanvasContext2D(\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    stitchContext.imageSmoothingEnabled = false;\n  }\n\n  const stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function (src, i, arr) {\n    const xPos = src.extent[0] - sourceDataExtent[0];\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\n    const srcWidth = getWidth(src.extent);\n    const srcHeight = getHeight(src.extent);\n\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(\n        src.image,\n        gutter,\n        gutter,\n        src.image.width - 2 * gutter,\n        src.image.height - 2 * gutter,\n        xPos * stitchScale,\n        yPos * stitchScale,\n        srcWidth * stitchScale,\n        srcHeight * stitchScale\n      );\n    }\n  });\n\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    context.scale(\n      sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio\n    );\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  releaseCanvas(stitchContext);\n  canvasPool.push(stitchContext.canvas);\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {boolean} [interpolate] Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    interpolate\n  ) {\n    super(tileCoord, TileState.IDLE, {interpolate: !!interpolate});\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../ImageTile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach((tile) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0]\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n","/**\n * @module ol/rotationconstraint\n */\nimport {toRadians} from './math.js';\n\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n  if (rotation !== undefined) {\n    return 0;\n  }\n  return undefined;\n}\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n  if (rotation !== undefined) {\n    return rotation;\n  }\n  return undefined;\n}\n\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n  const theta = (2 * Math.PI) / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\n        return rotation;\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} [tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(tolerance) {\n  tolerance = tolerance || toRadians(5);\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        if (Math.abs(rotation) <= tolerance) {\n          return 0;\n        }\n        return rotation;\n      }\n      return undefined;\n    }\n  );\n}\n","/**\n * @module ol/size\n */\n\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = size[0] + 2 * num;\n  dest[1] = size[1] + 2 * num;\n  return dest;\n}\n\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\n\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = (size[0] * ratio + 0.5) | 0;\n  dest[1] = (size[1] * ratio + 0.5) | 0;\n  return dest;\n}\n\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, dest) {\n  if (Array.isArray(size)) {\n    return size;\n  }\n  if (dest === undefined) {\n    dest = [size, size];\n  } else {\n    dest[0] = size;\n    dest[1] = size;\n  }\n  return dest;\n}\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.pop();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache'\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache'\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T} Value.\n   */\n  peek(key) {\n    if (!this.containsKey(key)) {\n      return undefined;\n    }\n    return this.entries_[key].value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already'\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n","/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport const DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport const DEFAULT_TILE_SIZE = 256;\n","/**\n * @module ol/transform\n */\nimport {WORKER_OFFSCREEN_CANVAS} from './has.js';\nimport {assert} from './asserts.js';\n\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 3×3 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n/**\n * @private\n * @type {Transform}\n */\nconst tmp_ = new Array(6);\n\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n  return [1, 0, 0, 1, 0, 0];\n}\n\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n  return set(transform, 1, 0, 0, 1, 0, 0);\n}\n\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n  const a1 = transform1[0];\n  const b1 = transform1[1];\n  const c1 = transform1[2];\n  const d1 = transform1[3];\n  const e1 = transform1[4];\n  const f1 = transform1[5];\n  const a2 = transform2[0];\n  const b2 = transform2[1];\n  const c2 = transform2[2];\n  const d2 = transform2[3];\n  const e2 = transform2[4];\n  const f2 = transform2[5];\n\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n\n  return transform1;\n}\n\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n}\n\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\n\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n}\n\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nexport function makeScale(target, x, y) {\n  return set(target, x, 0, 0, y, 0, 0);\n}\n\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  const sin = Math.sin(angle);\n  const cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` property of an HTMLElement's style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nexport function invert(source) {\n  return makeInverse(source, source);\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nexport function makeInverse(target, source) {\n  const det = determinant(source);\n  assert(det !== 0, 'Transformation matrix cannot be inverted');\n\n  const a = source[0];\n  const b = source[1];\n  const c = source[2];\n  const d = source[3];\n  const e = source[4];\n  const f = source[5];\n\n  target[0] = d / det;\n  target[1] = -b / det;\n  target[2] = -c / det;\n  target[3] = a / det;\n  target[4] = (c * f - d * e) / det;\n  target[5] = -(a * f - b * e) / det;\n\n  return target;\n}\n\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}\n\n/**\n * @type {HTMLElement}\n * @private\n */\nlet transformStringDiv;\n\n/**\n * A rounded string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nexport function toString(mat) {\n  const transformString = 'matrix(' + mat.join(', ') + ')';\n  if (WORKER_OFFSCREEN_CANVAS) {\n    return transformString;\n  }\n  const node =\n    transformStringDiv || (transformStringDiv = document.createElement('div'));\n  node.style.transform = transformString;\n  return node.style.transform;\n}\n","/**\n * @module ol/util\n */\n\n/**\n * @return {never} Any return.\n */\nexport function abstract() {\n  throw new Error('Unimplemented abstract method.');\n}\n\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nlet uidCounter_ = 0;\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nexport function getUid(obj) {\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport const VERSION = '8.1.0';\n"],"names":["Disposable","constructor","this","disposed","dispose","disposeInternal","listenImage","image","loadHandler","errorHandler","img","listening","decoding","loaded","listenerKeys","listenOnce","EventType","LOAD","src","IMAGE_DECODE","decode","then","catch","error","push","ERROR","forEach","unlistenByKey","load","Promise","resolve","reject","handleLoad","unlisten","handleError","Error","removeEventListener","addEventListener","decodeFallback","IDLE","LOADING","LOADED","EMPTY","ImageTile","Tile","tileCoord","state","crossOrigin","tileLoadFunction","options","super","crossOrigin_","src_","key","image_","Image","unlisten_","tileLoadFunction_","getImage","setImage","element","TileState","unlistenImage_","changed","handleImageError_","getBlankImage","handleImageLoad_","naturalWidth","naturalHeight","bind","ctx","createCanvasContext2D","fillStyle","fillRect","canvas","ObjectEvent","Event","type","oldValue","BaseObject","Observable","values","on","once","un","getUid","values_","undefined","setProperties","get","value","hasOwnProperty","getKeys","Object","keys","getProperties","assign","getPropertiesInternal","hasProperties","notify","eventType","hasListener","dispatchEvent","ObjectEventType","PROPERTYCHANGE","addChangeListener","listener","removeChangeListener","set","silent","applyProperties","source","unset","isEmpty","EventTarget","onInternal","onceInternal","unInternal","revision_","CHANGE","getRevision","Array","isArray","len","length","i","listen","ol_key","unByKey","ii","prototype","interimTile","transition_","transition","transitionStarts_","interpolate","release","setState","getKey","getInterimTile","tile","getState","refreshInterimChain","prev","getTileCoord","abstract","getAlpha","id","time","start","delta","easeIn","inTransition","endTransition","TileRange","minX","maxX","minY","maxY","contains","containsXY","containsTileRange","tileRange","x","y","equals","extend","getHeight","getSize","getWidth","intersects","createOrUpdate","CENTER","RESOLUTION","ROTATION","createExtent","extent","onlyCenter","smooth","center","resolution","size","isMoving","centerShift","viewWidth","viewHeight","shiftX","shiftY","clamp","ratio","Math","log","max","none","getViewportClampedResolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","min","getSmoothClampedResolution","maxResolution","minResolution","result","createSnapToResolutions","resolutions","direction","cappedMaxRes","capped","z","floor","linearFindNearest","createSnapToPower","power","tolerance","minZoomLevel","ceil","offset","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution","DEFAULT_MIN_ZOOM","View","hints_","animations_","updateAnimationKey_","projection_","createProjection","projection","viewportSize_","targetCenter_","targetResolution_","targetRotation_","nextCenter_","nextResolution_","nextRotation_","cancelAnchor_","disableCoordinateWarning","fromUserCoordinate","fromUserExtent","applyOptions_","properties","ViewProperty","resolutionConstraintInfo","createResolutionConstraint","maxResolution_","minResolution_","zoomFactor_","zoomFactor","resolutions_","padding_","padding","minZoom_","minZoom","centerConstraint","createCenterConstraint","resolutionConstraint","constraint","rotationConstraint","createRotationConstraint","constraints_","rotation","setRotation","setCenterInternal","setResolution","zoom","setZoom","oldPadding","getCenterInternal","newPadding","getResolution","offsetX","offsetY","getUpdatedOptions_","newOptions","getZoom","getRotation","animate","var_args","isDef","getAnimating","resolveConstraints","args","arguments","getProjection","anchor","animateInternal","apply","callback","animationCount","animationCallback","Date","now","slice","series","animation","complete","duration","easing","inAndOut","sourceCenter","targetCenter","sourceResolution","targetResolution","getResolutionForZoom","sourceRotation","modulo","PI","targetRotation","isNoopAnimation","setHint","ViewHint","ANIMATING","updateAnimations_","getInteracting","INTERACTING","cancelAnimations","j","jj","NaN","cancelAnimationFrame","more","seriesComplete","elapsed","fraction","progress","x0","y0","x1","y1","getViewportSize_","constrainedResolution","calculateCenterZoom","applyTargetState_","constrainedRotation","calculateCenterRotate","filter","Boolean","requestAnimationFrame","currentCenter","rotateCoordinate","addCoordinate","currentResolution","w","h","abs","cos","sin","setViewportSize","getCenter","toUserCoordinate","getConstraints","getConstrainResolution","getHints","hints","calculateExtent","calculateExtentInternal","toUserExtent","getViewportSizeMinusPadding_","assert","getForViewAndSize","getMaxResolution","getMinResolution","getMaxZoom","getZoomForResolution","setMaxZoom","maxZoom","getMinZoom","setMinZoom","setConstrainResolution","enabled","constrainResolution","getResolutions","getResolutionForExtent","getResolutionForExtentInternal","getResolutionForValueFunction","getConstrainedResolution","getValueForResolutionFunction","logPower","reducedSize","calculateCenterOn","nextCenter","nextResolution","nextRotation","getViewStateAndExtent","viewState","nearest","baseLevel","fit","geometryOrExtent","geometry","getSimplifiedGeometry","polygonFromExtent","getType","getExtent","rotate","userProjection","getUserProjection","clone","transform","fitInternal","rotatedExtentForGeometry","cosAngle","sinAngle","coords","getFlatCoordinates","stride","getStride","minRotX","Infinity","minRotY","maxRotX","maxRotY","rotX","rotY","rotatedExtent","isNaN","centerRot","centerX","centerY","getConstrainedCenter","VOID","centerOn","coordinate","position","centerOnInternal","calculateCenterShift","shiftedCenter","adjustCenter","deltaCoordinates","setCenter","adjustCenterInternal","adjustResolution","adjustResolutionInternal","adjustZoom","adjustRotation","adjustRotationInternal","newRotation","hint","doNotCancelAnims","forceMoving","newCenter","resolutionDirection","easeOut","beginInteraction","endInteraction","endInteractionInternal","getConstrainedZoom","targetZoom","targetRes","returnValue","setTimeout","smoothExtentConstraint","constrainOnlyCenter","multiWorld","isGlobal","centerNone","defaultMaxZoom","defaultZoomFactor","smoothResolutionConstraint","projExtent","METERS_PER_UNIT","degrees","getMetersPerUnit","defaultMaxResolution","DEFAULT_TILE_SIZE","defaultMinResolution","enableRotation","constrainRotation","createSnapToZero","rotationNone","createSnapToN","disable","coordinatesEqual","binarySearch","haystack","needle","comparator","mid","cmp","ascending","low","high","found","a","b","descending","arr","target","n","candidate","reverseSubArray","begin","end","tmp","data","extension","arr1","arr2","len1","isSorted","func","strict","compare","every","currentVal","index","res","assertion","errorMessage","HEX_COLOR_RE_","NAMED_COLOR_RE_","asString","color","toString","fromNamed","el","document","createElement","style","body","appendChild","rgb","getComputedStyle","removeChild","fromString","MAX_CACHE_SIZE","cache","cacheSize","s","fromStringInternal_","asArray","r","g","exec","d","hasAlpha","parseInt","substr","startsWith","split","map","Number","normalize","round","isStringColor","test","levels","info","warn","level","console","add","coordinate1","coordinate2","angle","scale","wrapX","canWrapX","worldWidth","worldsAway","getWorldsAway","sourceExtentWidth","projectionExtent","width","height","canvasPool","settings","shift","WORKER_OFFSCREEN_CANVAS","OffscreenCanvas","getContext","releaseCanvas","context","clearRect","replaceNode","newNode","oldNode","parent","parentNode","replaceChild","removeNode","node","removeChildren","lastChild","replaceChildren","children","oldChildren","childNodes","oldChild","newChild","insertBefore","t","linear","thisArg","originalListener","eventsKey","clear","BaseEvent","propagationStopped","defaultPrevented","preventDefault","stopPropagation","BLUR","CLEAR","CONTEXTMENU","CLICK","DBLCLICK","DRAGENTER","DRAGOVER","DROP","FOCUS","KEYDOWN","KEYPRESS","RESIZE","TOUCHMOVE","WHEEL","Target","eventTarget_","pendingRemovals_","dispatching_","listeners_","listeners","listenersForType","includes","event","isString","evt","dispatching","pendingRemovals","propagate","handleEvent","call","pr","getListeners","indexOf","splice","boundingExtent","coordinates","createEmpty","extendCoordinate","_boundingExtentXYs","xs","ys","dest","buffer","closestSquaredDistanceXY","dx","dy","containsCoordinate","containsExtent","extent1","extent2","coordinateRelationship","relationship","Relationship","UNKNOWN","LEFT","RIGHT","BELOW","ABOVE","INTERSECTING","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","flatCoordinates","extendFlatCoordinates","extendXY","forEachCorner","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","getCorner","corner","x2","y2","x3","y3","getRotatedViewport","cosRotation","sinRotation","xCos","xSin","yCos","ySin","getIntersection","intersection","returnOrUpdate","intersectsSegment","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","stops","l","wrapAndSliceX","isFinite","TRUE","FALSE","memoizeOne","fn","lastResult","lastArgs","lastThis","called","nextArgs","arrayEquals","tmpTransform","createTransform","Geometry","extent_","extentRevision_","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","simplifyTransformedInternal","revision","squaredTolerance","simplifyTransformed","closestPointXY","closestPoint","minSquaredDistance","coord","getClosestPoint","point","intersectsCoordinate","computeExtent","sx","sy","simplify","intersectsExtent","translate","deltaX","deltaY","destination","sourceProj","getUnits","inCoordinates","outCoordinates","pixelExtent","projectedExtent","getWorldExtent","composeTransform","transform2D","getTransform","Point","SimpleGeometry","layout","setCoordinates","squaredDistance","squaredDx","getCoordinates","setLayout","deflateCoordinate","LinearRing","maxDelta_","maxDeltaRevision_","setFlatCoordinates","sqrt","maxSquaredDelta","assignClosestPoint","linearRingArea","inflateCoordinates","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","douglasPeucker","deflateCoordinates","Polygon","ends","ends_","flatInteriorPointRevision_","flatInteriorPoint_","orientedRevision_","orientedFlatCoordinates_","appendLinearRing","linearRing","polygon","arrayMaxSquaredDelta","assignClosestArrayPoint","linearRingsContainsXY","getOrientedFlatCoordinates","linearRingsArea","right","orientLinearRings","inflateCoordinatesArray","getEnds","getFlatInteriorPoint","flatCenter","getInteriorPointOfArray","getInteriorPoint","getLinearRingCount","getLinearRing","getLinearRings","linearRings","linearRingsAreOriented","simplifiedEnds","quantizeArray","intersectsLinearRingArray","deflateCoordinatesArray","fromExtent","getFirstCoordinate","getLastCoordinate","getLayout","simplifiedGeometry","getStrideForLayout","nesting","getLayoutForStride","transformGeom2D","simpleGeometry","twiceArea","linearRingss","endss","assignClosest","offset1","offset2","lerp","squaredDelta","multiArrayMaxSquaredDelta","maxDelta","isRing","tmpPoint","assignClosestMultiArrayPoint","linearRingContainsExtent","outside","linearRingContainsXY","wn","linearRingssContainsXY","coordinatess","deflateMultiCoordinatesArray","coordinatesss","inflateMultiCoordinatesArray","flatCenters","flatCentersOffset","intersections","rr","pointX","maxSegmentLength","sort","segmentLength","getInteriorPointsOfMultiArray","interiorPoints","intersectsLineString","coordinatesExtent","forEachSegment","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingMultiArray","linearRingIsClockwise","edge","isClockwise","linearRingssAreOriented","reverse","reverseCoordinates","orientLinearRingsArray","ret","simplifiedOffset","markers","stack","last","pop","first","maxSquaredDistance","squaredSegmentDistance","douglasPeuckerArray","snap","quantize","dx1","dy1","dx2","dy2","quantizeMultiArray","simplifiedEndss","anchorX","anchorY","k","ua","navigator","userAgent","toLowerCase","FIREFOX","SAFARI","SAFARI_BUG_237906","WEBKIT","MAC","DEVICE_PIXEL_RATIO","devicePixelRatio","WorkerGlobalScope","self","PASSIVE_EVENT_LISTENERS","passive","defineProperty","window","BaseLayer","background_","background","LayerProperty","OPACITY","opacity","VISIBLE","visible","Z_INDEX","zIndex","MAX_RESOLUTION","MIN_RESOLUTION","MIN_ZOOM","MAX_ZOOM","className_","className","state_","getBackground","getClassName","getLayerState","managed","layer","getZIndex","getOpacity","getVisible","getLayersArray","array","getLayerStatesArray","states","EXTENT","getSourceState","setBackground","setExtent","setMaxResolution","setMinResolution","setOpacity","setVisible","setZIndex","zindex","Layer","baseOptions","mapPrecomposeKey_","mapRenderKey_","sourceChangeKey_","renderer_","sourceReady_","rendered","render","setMap","SOURCE","handleSourcePropertyChange_","setSource","getSource","getRenderSource","handleSourceChange_","getFeatures","pixel","getData","isVisible","view","frameState","getMapInternal","layerState","getView","layerStatesArray","getLayerGroup","find","layerExtent","inView","getAttributions","attributions","layerRenderer","getRenderer","prepareFrame","renderFrame","unrender","setMapInternal","MAP","RenderEventType","PRECOMPOSE","renderEvent","some","arrayLayerState","createRenderer","hasRenderer","PRELOAD","USE_INTERIM_TILES_ON_ERROR","BaseTileLayer","preload","useInterimTilesOnError","setPreload","setUseInterimTilesOnError","getPreload","TileProperty","getUseInterimTilesOnError","asImageLike","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","asArrayLike","Uint8Array","Uint8ClampedArray","Float32Array","DataView","sharedContext","toArray","willReadFrequently","drawImage","getImageData","defaultSize","DataTile","loader_","loader","data_","error_","size_","imageData","getError","ReprojDataTile","pixelRatio_","pixelRatio","gutter_","gutter","reprojData_","reprojError_","reprojSize_","sourceTileGrid_","sourceTileGrid","targetTileGrid_","targetTileGrid","wrappedTileCoord_","wrappedTileCoord","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","sourceProjExtent","targetProj","calculateSourceExtentResolution","errorThresholdInPixels","errorThreshold","ERROR_THRESHOLD","triangulation_","Triangulation","getTriangles","getZForResolution","sourceExtent","calculateSourceExtent","sourceRange","getTileRangeForExtentAndZ","getTile","getTileFunction","srcX","srcY","reproject_","dataSources","tileData","arrayData","pixelSize","isFloat","pixelCount","DataType","tileDataR","bytesPerElement","BYTES_PER_ELEMENT","bytesPerPixel","bytesPerRow","byteLength","bandCount","packedLength","packedData","dataIndex","rowOffset","colCount","rowIndex","colIndex","dataType","getTileSize","targetWidth","targetHeight","dataR","dataU","reprojs","reproj","sources","dataSource","createImageData","putImageData","renderReprojected","leftToLoad","sourceListenKey","unlistenSources_","BaseTileRepresentation","handleTileChange_","helper_","helper","ready","setTile","uploadTile","setReady","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","STREAM_DRAW","STATIC_DRAW","DYNAMIC_DRAW","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","FLOAT","CONTEXT_IDS","attributes","request_webgl2","preserveDrawingBuffer","antialias","contextsToTry","e","BufferUsage","WebGLArrayBuffer","usage","ofSize","getArrayClassForType","fromArray","from","fromArrayBuffer","getArray","getUsage","Uint32Array","bindAndConfigure","gl","texture","resampleFilter","LINEAR","NEAREST","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","uploadImageTexture","texImage2D","RGBA","uploadDataTexture","getGL","textureType","canInterpolate","getExtension","format","unpackAlignment","LUMINANCE","LUMINANCE_ALPHA","RGB","oldUnpackAlignment","getParameter","UNPACK_ALIGNMENT","pixelStorei","pixelContext","createPixelContext","TileTexture","textures","renderSize_","toSize","grid","flushBufferData","ReprojTile","createTexture","sourceTileSize","textureCount","textureDataArrays","textureIndex","dataValue","pixelIndex","bandIndex","textureData","textureBandIndex","deleteBuffer","deleteTexture","getImagePixelData_","renderCol","renderRow","renderWidth","renderHeight","sourceWidth","sourceHeight","sourceWidthWithoutGutter","sourceHeightWithoutGutter","sourceCol","sourceRow","err","getArrayPixelData_","sourceSize","getPixelData","LOST","RESTORED","DEFAULT_VERTEX_SHADER","DEFAULT_FRAGMENT_SHADER","WebGLPostProcessingPass","gl_","webGlContext","scaleRatio_","scaleRatio","renderTargetTexture_","renderTargetTextureSize_","frameBuffer_","createFramebuffer","depthBuffer_","createRenderbuffer","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","fragmentShader","FRAGMENT_SHADER","renderTargetProgram_","createProgram","attachShader","linkProgram","renderTargetVerticesBuffer_","createBuffer","verticesArray","bindBuffer","bufferData","renderTargetAttribLocation_","getAttribLocation","renderTargetUniformLocation_","getUniformLocation","renderTargetOpacityLocation_","renderTargetTextureLocation_","uniforms_","uniforms","name","location","init","textureSize","drawingBufferWidth","drawingBufferHeight","bindFramebuffer","FRAMEBUFFER","getFrameBuffer","bindRenderbuffer","RENDERBUFFER","getDepthBuffer","viewport","internalFormat","border","framebufferTexture2D","COLOR_ATTACHMENT0","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","nextPass","preCompose","postCompose","activeTexture","TEXTURE0","canvasId","renderTargets","getContextAttributes","clearColor","clearDepth","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","DEPTH_TEST","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","useProgram","enableVertexAttribArray","vertexAttribPointer","uniform2f","uniform1i","layerIndex","uniform1f","applyUniforms","drawArrays","TRIANGLES","textureSlot","uniform","ImageData","uniform3f","uniform4f","create","fromTransform","mat4","DefaultUniform","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","TIME","ZOOM","VIEWPORT_SIZE_PX","PIXEL_RATIO","HIT_DETECTION","AttributeType","canvasCache","getSharedCanvasCacheKey","uniqueCanvasCacheKeyCount","getUniqueCanvasCacheKey","getOrCreateContext","cacheItem","left","users","loseContext","WebGLHelper","boundHandleWebGLContextLost_","handleWebGLContextLost","boundHandleWebGLContextRestored_","handleWebGLContextRestored","canvasCacheKey_","canvasCacheKey","bufferCache_","extensionCache_","currentProgram_","needsToBeRecreated_","ContextEventType","offsetRotateMatrix_","offsetScaleMatrix_","tmpMat4_","uniformLocationsByProgram_","attribLocationsByProgram_","setUniforms","postProcessPasses_","postProcesses","shaderCompileErrors_","startTime_","addUniforms","canvasCacheKeyMatches","bufferKey","bufferCache","webGlBuffer","buf","bufferCacheEntry","isContextLost","prepareDraw","disableAlphaBlend","enableDepth","getCanvas","depthRange","ZERO","depthFunc","LEQUAL","slot","uniformName","prepareDrawToRenderTarget","renderTarget","getFramebuffer","getDepthbuffer","getTexture","drawElements","elementType","elementSize","numItems","offsetInBytes","finalizeDraw","applyFrameState","setUniformFloatValue","setUniformFloatVec2","applyHitDetectionUniform","loc","HTMLImageElement","prevValue","imageReady","setUniformMatrixValue","program","shader","getProgram","fragmentShaderSource","vertexShaderSource","getShaderParameter","COMPILE_STATUS","message","getShaderInfoLog","deleteShader","getProgramParameter","LINK_STATUS","getProgramInfoLog","programUid","getAttributeLocation","makeProjectionTransform","uniform2fv","setUniformFloatVec4","uniform4fv","uniformMatrix4fv","enableAttributeArray_","attribName","enableAttributes","computeAttributesStride","attr","getByteSizeFromType","needsToBeRecreated","Uint16Array","WebGLLayerRenderer","LayerRenderer","inversePixelTransform_","pixelContext_","postProcesses_","removeHelper","dispatchPreComposeEvent","dispatchPostComposeEvent","getLayer","RenderEvent","POSTCOMPOSE","reset","incrementGroup","groupNumber","renderer","layerClassName","mapId","afterHelperCreated","prepareFrameInternal","dispatchRenderEvent_","preRender","PRERENDER","postRender","POSTRENDER","Uniforms","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","RENDER_EXTENT","GLOBAL_ALPHA","empty","depthForZ","newTileRepresentationLookup","tileIds","Set","representationsByZ","lookupHasTile","tileRepresentationLookup","has","addTileRepresentationToLookup","tileRepresentation","getRenderExtent","getWrapX","gridExtent","getTileGridForProjection","getCacheKey","getTileCoordKey","WebGLBaseTileLayerRenderer","tileLayer","renderComplete","tileTransform_","tempMat4","createMat4","tempTileRange_","tempTileCoord_","createTileCoord","tempSize_","tileRepresentationCache","LRUCache","isDrawableTile_","tileState","clearCache","createTileRepresentation","enqueueTiles","initialZ","tileSource","tileGrid","getGutterForProjection","tileSourceKey","wantedTiles","minZ","zDirection","tileResolution","cacheKey","containsKey","tileQueueKey","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","beforeTilesRender","tilesWithAlpha","renderTile","tileTransform","renderExtent","tileSize","tileOrigin","tileExtent","depth","alpha","drawTile_","tileZ","alphaLookup","tileCoordKey","getOrigin","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","tileCenterI","tileCenterJ","resetTransform","scaleTransform","rotateTransform","translateTransform","nextExtent","targetZ","uid","blend","coveredByChildren","findAltTiles_","parentZ","coveredByParent","zs","canExpireCache","postRenderFunction","updateCacheSize","expireCache","postRenderFunctions","altZ","getTileRangeForTileCoordAndZ","covered","BaseUniforms","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","Attributes","TEXTURE_COORD","attributeDescriptions","WebGLTileLayerRenderer","program_","vertexShader_","fragmentShader_","indices_","paletteTextures_","paletteTextures","tileTexture","paletteIndex","paletteTexture","mat4FromTransform","gutterExtent","pixelToCoordinateTransform","getSources","tileTextureCache","getTileCoordForCoordAndZ","col","row","deleteProgram","PaletteTexture","texture_","ValueTypes","NUMBER","STRING","COLOR","BOOLEAN","NUMBER_ARRAY","ANY","NONE","getTypeFromHint","typeHint","Operators","getValueType","JSON","stringify","valueArr","onlyNumbers","v","operator","getReturnType","isTypeUnique","valueType","log2","printTypes","join","computeOperatorFunctionName","functions","numberToGlsl","arrayToGlsl","colorToGlsl","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","string","stringToGlsl","expressionToGlsl","expectedType","returnType","toGlsl","possibleType","assertNotEmptyType","assertNumber","assertNumbers","assertString","assertBoolean","assertArgsCount","count","assertArgsMinCount","assertArgsMaxCount","assertArgsEven","assertArgsOdd","types","descriptor","assertSingleType","assertOfType","expectedTypes","uniformNameForVariable","variableName","outputType","existing","prefix","inFragmentShader","variables","initialValue","PALETTE_TEXTURE_ARRAY","colors","numColors","palette","paletteName","GET_BAND_VALUE_FUNC","getEqualOperator","getDecisionOperator","arg","parseStyle","pipeline","contrast","exposure","saturation","gamma","brightness","numVariables","variable","uniformDeclarations","functionDefintions","band","ifBlocks","colorIndex","textureName","bandExpression","xOffsetExpression","yOffsetExpression","computeType","substring","getGeometries","feature","getGeometry","parsedArgs","interpolation","inputType","input","exponent","stop1","output1","stop2","output2","fallback","match","output","condition","funcName","tests","WebGLTileLayer","sources_","renderedSource_","renderedResolution_","style_","cacheSize_","styleVariables_","handleSourceUpdate_","setStyle","getSourceBandCount_","MAX_SAFE_INTEGER","parsedStyle","renderSources","sourceState","onChange","altSources","updateStyleVariables","solveLinearSystem","mat","maxRow","maxEl","absValue","coef","m","toRadians","angleInDegrees","toFixed","decimals","factor","object","property","Projection","code_","code","units_","units","worldExtent_","worldExtent","axisOrientation_","axisOrientation","global_","global","canWrapX_","getPointResolutionFunc_","getPointResolution","defaultTileGrid_","metersPerUnit_","metersPerUnit","getCode","getAxisOrientation","setGlobal","getDefaultTileGrid","setDefaultTileGrid","setWorldExtent","setGetPointResolution","getPointResolutionFunc","RADIUS","HALF_SIZE","WORLD_EXTENT","MAX_SAFE_Y","tan","EPSG3857Projection","cosh","PROJECTIONS","fromEPSG4326","dimension","toEPSG4326","atan","exp","EPSG4326Projection","replace","transforms","sourceCode","destinationCode","DEFAULT_RADIUS","getDistance","c1","c2","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","atan2","showCoordinateWarning","hide","cloneTransform","identityTransform","addProjection","addProj","addTransformFunc","addProjections","projections","projectionLike","getProj","pointResolution","getter","projUnits","getTransformFromProjections","vertices","addEquivalentProjections","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","defaultCode","equivalent","equalUnits","transformFunc","sourceProjection","destinationProjection","getTransformFunc","transformExtent","destProjection","toUserResolution","sourceUnits","userUnits","addCommon","EPSG3857_PROJECTIONS","EPSG4326_PROJECTIONS","inversePixelTransform","RENDERCOMPLETE","boundHandleImageChange_","handleImageChange_","layer_","declutterExecutorGroup","loadedTileCallback","tiles","createLoadedTileFinder","forEachLoadedTile","forEachFeatureAtCoordinate","hitTolerance","matches","handleFontsChanged","ImageState","renderIfReadyAndVisible","loadImage","imageState","brokenDiagonalRendering_","drawTestTriangle","u1","v1","u2","v2","beginPath","moveTo","lineTo","closePath","save","clip","restore","verifyBrokenDiagonalRendering","isBrokenDiagonalRendering","globalCompositeOperation","calculateSourceResolution","targetMetersPerUnit","sourceMetersPerUnit","compensationFactor","triangulation","renderEdges","imageSmoothingEnabled","pixelRound","sourceDataExtent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","targetTopLeft","triangle","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","strokeStyle","lineWidth","stroke","renderEdges_","canvas_","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","addQuad_","leftBound","newTriangle","addTriangle_","aSrc","bSrc","cSrc","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","targetCoverageX","isNotFinite","centerSrc","centerSrcEstimX","centerSrcErrorSquared","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","theta","hasArea","highWaterMark","count_","entries_","oldest_","newest_","getCount","keep","f","entry","value_","key_","newer","older","remove","getValues","peekLast","peekLastKey","peekFirstKey","peek","setSize","getKeyZXY","fromKey","hash","withinExtentAndZ","getFullTileRange","DEFAULT_MAX_ZOOM","tmp_","multiply","transform1","transform2","a1","b1","d1","e1","f1","a2","b2","d2","e2","f2","setFromArray","makeScale","compose","makeInverse","det","determinant","transformStringDiv","transformString","uidCounter_","obj","ol_uid","String"],"sourceRoot":""}