/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.111
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as R}from"./chunk-VFOAUMZG.js";import{a as It}from"./chunk-4M7FKQYC.js";import{a as M}from"./chunk-EMZN2RVW.js";import{a as bt}from"./chunk-PNRMC4IG.js";import"./chunk-JMG4RN2X.js";import"./chunk-PG5ZS3T4.js";import"./chunk-OH4CN3UY.js";import"./chunk-AAJ456AA.js";import{a as W}from"./chunk-JZL634RF.js";import"./chunk-DV7DPSRL.js";import"./chunk-4FFHQQYZ.js";import{c as z}from"./chunk-KCIWEUSR.js";import"./chunk-7XDW3BZW.js";import{a as o,b as nt,c as j}from"./chunk-F33YCXD2.js";import{a as et}from"./chunk-DUBQPPQZ.js";import"./chunk-CG3JQAX7.js";import"./chunk-P3JQY4NV.js";import"./chunk-K36PKEJW.js";import"./chunk-KD2PMTHD.js";import{e as A}from"./chunk-ZUCO5WNM.js";var kt=new o,Bt=new j,Nt=new z,E={min:void 0,max:void 0,indexBytesPerElement:void 0};function Pt(t){let e=new Float64Array(t),n=0;E.indexBytesPerElement=e[n++],E.min=e[n++],E.max=e[n++],o.unpack(e,n,kt),n+=o.packedLength,j.unpack(e,n,Bt),n+=j.packedLength,z.unpack(e,n,Nt)}function Tt(t){let e=t.length,n=0;for(let r=0;r<e;++r)n+=R.packedLength+3+t[r].batchIds.length;return n}function Ct(t,e,n){let r=e.length,o=2+r*M.packedLength+1+Tt(n),a=new Float64Array(o),i=0;a[i++]=t,a[i++]=r;for(let f=0;f<r;++f)M.pack(e[f],a,i),i+=M.packedLength;let s=n.length;a[i++]=s;for(let f=0;f<s;++f){let t=n[f];R.pack(t.color,a,i),i+=R.packedLength,a[i++]=t.offset,a[i++]=t.count;let e=t.batchIds,r=e.length;a[i++]=r;for(let n=0;n<r;++n)a[i++]=e[n]}return a}var yt=32767,wt=new o,Ht=new o,St=new o,Ut=new o,Ft=new o,Lt=new nt,Mt=new z;function Rt(t,e){let n;Pt(t.packedBuffer),n=2===E.indexBytesPerElement?new Uint16Array(t.indices):new Uint32Array(t.indices);let r=new Uint16Array(t.positions),a=new Uint32Array(t.counts),i=new Uint32Array(t.indexCounts),s=new Uint32Array(t.batchIds),f=new Uint32Array(t.batchTableColors),c=new Array(a.length),h=kt,l=Bt,u=Nt,m=E.min,p=E.max,d=t.minimumHeights,k=t.maximumHeights;A(d)&&A(k)&&(d=new Float32Array(d),k=new Float32Array(k));let g,w,b,y=r.length/2,I=r.subarray(0,y),N=r.subarray(y,2*y);bt.zigZagDeltaDecode(I,N);let j=new Float64Array(3*y);for(g=0;g<y;++g){let t=I[g],e=N[g],n=et.lerp(u.west,u.east,t/yt),r=et.lerp(u.south,u.north,e/yt),a=nt.fromRadians(n,r,0,Lt),i=l.cartographicToCartesian(a,wt);o.pack(i,j,3*g)}let x=a.length,L=new Array(x),T=new Array(x),U=0,F=0;for(g=0;g<x;++g)L[g]=U,T[g]=F,U+=a[g],F+=i[g];let P=new Float32Array(3*y*2),S=new Uint16Array(2*y),C=new Uint32Array(T.length),O=new Uint32Array(i.length),B=[],D={};for(g=0;g<x;++g)b=f[g],A(D[b])?(D[b].positionLength+=a[g],D[b].indexLength+=i[g],D[b].batchIds.push(g)):D[b]={positionLength:a[g],indexLength:i[g],offset:0,indexOffset:0,batchIds:[g]};let G,Y=0,Z=0;for(b in D)if(D.hasOwnProperty(b)){G=D[b],G.offset=Y,G.indexOffset=Z;let t=2*G.positionLength,e=2*G.indexLength+6*G.positionLength;Y+=t,Z+=e,G.indexLength=e}let H=[];for(b in D)D.hasOwnProperty(b)&&(G=D[b],H.push({color:R.fromRgba(parseInt(b)),offset:G.indexOffset,count:G.indexLength,batchIds:G.batchIds}));for(g=0;g<x;++g){b=f[g],G=D[b];let t=G.offset,e=3*t,r=t,y=L[g],I=a[g],N=s[g],E=m,x=p;A(d)&&A(k)&&(E=d[g],x=k[g]);let U=Number.POSITIVE_INFINITY,F=Number.NEGATIVE_INFINITY,R=Number.POSITIVE_INFINITY,W=Number.NEGATIVE_INFINITY;for(w=0;w<I;++w){let t=o.unpack(j,3*y+3*w,wt);l.scaleToGeodeticSurface(t,t);let n=l.cartesianToCartographic(t,Lt),a=n.latitude,i=n.longitude;U=Math.min(a,U),F=Math.max(a,F),R=Math.min(i,R),W=Math.max(i,W);let s=l.geodeticSurfaceNormal(t,Ht),f=o.multiplyByScalar(s,E,St),c=o.add(t,f,Ut);f=o.multiplyByScalar(s,x,f);let u=o.add(t,f,Ft);o.subtract(u,h,u),o.subtract(c,h,c),o.pack(u,P,e),o.pack(c,P,e+3),S[r]=N,S[r+1]=N,e+=6,r+=2}u=Mt,u.west=R,u.east=W,u.south=U,u.north=F,c[g]=M.fromRectangle(u,m,p,l);let Y=G.indexOffset,Z=T[g],H=i[g];for(C[g]=Y,w=0;w<H;w+=3){let e=n[Z+w]-y,r=n[Z+w+1]-y,o=n[Z+w+2]-y;B[Y++]=2*e+t,B[Y++]=2*r+t,B[Y++]=2*o+t,B[Y++]=2*o+1+t,B[Y++]=2*r+1+t,B[Y++]=2*e+1+t}for(w=0;w<I;++w){let e=w,n=(w+1)%I;B[Y++]=2*e+1+t,B[Y++]=2*n+t,B[Y++]=2*e+t,B[Y++]=2*e+1+t,B[Y++]=2*n+1+t,B[Y++]=2*n+t}G.offset+=2*I,G.indexOffset=Y,O[g]=Y-C[g]}B=W.createTypedArray(P.length/3,B);let J=H.length;for(let o=0;o<J;++o){let t=H[o].batchIds,e=0,n=t.length;for(let r=0;r<n;++r)e+=O[t[r]];H[o].count=e}let V=2===B.BYTES_PER_ELEMENT?W.UNSIGNED_SHORT:W.UNSIGNED_INT,_=Ct(V,c,H);return e.push(P.buffer,B.buffer,C.buffer,O.buffer,S.buffer,_.buffer),{positions:P.buffer,indices:B.buffer,indexOffsets:C.buffer,indexCounts:O.buffer,batchIds:S.buffer,packedBuffer:_.buffer}}var Jt=It(Rt);export{Jt as default};