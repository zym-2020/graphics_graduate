/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.111
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as M}from"./chunk-C4WD3G7A.js";import{a as ht}from"./chunk-NLQJPKTT.js";import"./chunk-J4D4SQY2.js";import"./chunk-Y33I6CKI.js";import"./chunk-YXVAQU2G.js";import{a as _t}from"./chunk-N52FZRFP.js";import{a as J}from"./chunk-WIRUK4BS.js";import"./chunk-JMG4RN2X.js";import"./chunk-PG5ZS3T4.js";import{b as yt}from"./chunk-BVOZOPDI.js";import{a as Pt}from"./chunk-EFCSU2FF.js";import"./chunk-BSXS3UVL.js";import"./chunk-OH4CN3UY.js";import"./chunk-AAJ456AA.js";import{a as Nt}from"./chunk-JZL634RF.js";import{a as Ct}from"./chunk-3UAKIC5Y.js";import{b as Mt,c as Vt,d as x}from"./chunk-QEWKHB6D.js";import{d as St}from"./chunk-DV7DPSRL.js";import"./chunk-4FFHQQYZ.js";import{c as Et}from"./chunk-KCIWEUSR.js";import{a as F}from"./chunk-7XDW3BZW.js";import{a as o,b as bt,c as I}from"./chunk-F33YCXD2.js";import{a as st}from"./chunk-DUBQPPQZ.js";import"./chunk-CG3JQAX7.js";import"./chunk-P3JQY4NV.js";import{a as B}from"./chunk-K36PKEJW.js";import{b as it}from"./chunk-KD2PMTHD.js";import{e as X}from"./chunk-ZUCO5WNM.js";var zt=new o,kt=new o,wt=new o,Tt=new o,jt=new o,Ht=new o,at=new o,ft=new o;function Ut(t,e){for(let o=0;o<t.length;o++)t[o]=e.scaleToGeodeticSurface(t[o],t[o]);return t}function Z(t,e,r,i,a,n){let s=t.normals,l=t.tangents,u=t.bitangents,d=o.normalize(o.cross(r,e,at),at);n.normal&&M.addAttribute(s,e,i,a),n.tangent&&M.addAttribute(l,d,i,a),n.bitangent&&M.addAttribute(u,r,i,a)}function Bt(t,e,r){let i,a,n,s=t.positions,l=t.corners,u=t.endPositions,d=t.lefts,m=t.normals,h=new Ct,c=0,f=0,p=0;for(a=0;a<s.length;a+=2)n=s[a].length-3,c+=n,p+=2*n,f+=s[a+1].length-3;for(c+=3,f+=3,a=0;a<l.length;a++){i=l[a];let t=l[a].leftPositions;X(t)?(n=t.length,c+=n,p+=n):(n=l[a].rightPositions.length,f+=n,p+=n)}let g,A=X(u);A&&(g=u[0].length-3,c+=g,f+=g,g/=3,p+=6*g);let b,y,_,w,v,T,I=c+f,k=new Float64Array(I),N=e.normal?new Float32Array(I):void 0,j=e.tangent?new Float32Array(I):void 0,E=e.bitangent?new Float32Array(I):void 0,P={normals:N,tangents:j,bitangents:E},O=0,D=I-1,B=zt,S=kt,W=g/2,V=Nt.createTypedArray(I/3,p),L=0;if(A){T=wt,v=Tt;let t=u[0];for(B=o.fromArray(m,0,B),S=o.fromArray(d,0,S),a=0;a<W;a++)T=o.fromArray(t,3*(W-1-a),T),v=o.fromArray(t,3*(W+a),v),M.addAttribute(k,v,O),M.addAttribute(k,T,void 0,D),Z(P,B,S,O,D,e),y=O/3,w=y+1,b=(D-2)/3,_=b-1,V[L++]=b,V[L++]=y,V[L++]=_,V[L++]=_,V[L++]=y,V[L++]=w,O+=3,D-=3}let J,R,Q=0,U=0,G=s[Q++],K=s[Q++];for(k.set(G,O),k.set(K,D-K.length+1),S=o.fromArray(d,U,S),n=K.length-3,a=0;a<n;a+=3)J=r.geodeticSurfaceNormal(o.fromArray(G,a,at),at),R=r.geodeticSurfaceNormal(o.fromArray(K,n-a,ft),ft),B=o.normalize(o.add(J,R,B),B),Z(P,B,S,O,D,e),y=O/3,w=y+1,b=(D-2)/3,_=b-1,V[L++]=b,V[L++]=y,V[L++]=_,V[L++]=_,V[L++]=y,V[L++]=w,O+=3,D-=3;for(J=r.geodeticSurfaceNormal(o.fromArray(G,n,at),at),R=r.geodeticSurfaceNormal(o.fromArray(K,n,ft),ft),B=o.normalize(o.add(J,R,B),B),U+=3,a=0;a<l.length;a++){let t;i=l[a];let u,h,c=i.leftPositions,f=i.rightPositions,p=Ht,g=wt,A=Tt;if(B=o.fromArray(m,U,B),X(c)){for(Z(P,B,S,void 0,D,e),D-=3,u=w,h=_,t=0;t<c.length/3;t++)p=o.fromArray(c,3*t,p),V[L++]=u,V[L++]=h-t-1,V[L++]=h-t,M.addAttribute(k,p,void 0,D),g=o.fromArray(k,3*(h-t-1),g),A=o.fromArray(k,3*u,A),S=o.normalize(o.subtract(g,A,S),S),Z(P,B,S,void 0,D,e),D-=3;p=o.fromArray(k,3*u,p),g=o.subtract(o.fromArray(k,3*h,g),p,g),A=o.subtract(o.fromArray(k,3*(h-t),A),p,A),S=o.normalize(o.add(g,A,S),S),Z(P,B,S,O,void 0,e),O+=3}else{for(Z(P,B,S,O,void 0,e),O+=3,u=_,h=w,t=0;t<f.length/3;t++)p=o.fromArray(f,3*t,p),V[L++]=u,V[L++]=h+t,V[L++]=h+t+1,M.addAttribute(k,p,O),g=o.fromArray(k,3*u,g),A=o.fromArray(k,3*(h+t),A),S=o.normalize(o.subtract(g,A,S),S),Z(P,B,S,O,void 0,e),O+=3;p=o.fromArray(k,3*u,p),g=o.subtract(o.fromArray(k,3*(h+t),g),p,g),A=o.subtract(o.fromArray(k,3*h,A),p,A),S=o.normalize(o.negate(o.add(A,g,S),S),S),Z(P,B,S,void 0,D,e),D-=3}for(G=s[Q++],K=s[Q++],G.splice(0,3),K.splice(K.length-3,3),k.set(G,O),k.set(K,D-K.length+1),n=K.length-3,U+=3,S=o.fromArray(d,U,S),t=0;t<K.length;t+=3)J=r.geodeticSurfaceNormal(o.fromArray(G,t,at),at),R=r.geodeticSurfaceNormal(o.fromArray(K,n-t,ft),ft),B=o.normalize(o.add(J,R,B),B),Z(P,B,S,O,D,e),w=O/3,y=w-1,_=(D-2)/3,b=_+1,V[L++]=b,V[L++]=y,V[L++]=_,V[L++]=_,V[L++]=y,V[L++]=w,O+=3,D-=3;O-=3,D+=3}if(B=o.fromArray(m,m.length-3,B),Z(P,B,S,O,D,e),A){O+=3,D-=3,T=wt,v=Tt;let t=u[1];for(a=0;a<W;a++)T=o.fromArray(t,3*(g-a-1),T),v=o.fromArray(t,3*a,v),M.addAttribute(k,T,void 0,D),M.addAttribute(k,v,O),Z(P,B,S,O,D,e),w=O/3,y=w-1,_=(D-2)/3,b=_+1,V[L++]=b,V[L++]=y,V[L++]=_,V[L++]=_,V[L++]=y,V[L++]=w,O+=3,D-=3}if(h.position=new x({componentDatatype:F.DOUBLE,componentsPerAttribute:3,values:k}),e.st){let t,e,o=new Float32Array(I/3*2),r=0;if(A){c/=3,f/=3;let i=Math.PI/(g+1);e=1/(c-g+1),t=1/(f-g+1);let n,s=g/2;for(a=s+1;a<g+1;a++)n=st.PI_OVER_TWO+i*a,o[r++]=t*(1+Math.cos(n)),o[r++]=.5*(1+Math.sin(n));for(a=1;a<f-g+1;a++)o[r++]=a*t,o[r++]=0;for(a=g;a>s;a--)n=st.PI_OVER_TWO-a*i,o[r++]=1-t*(1+Math.cos(n)),o[r++]=.5*(1+Math.sin(n));for(a=s;a>0;a--)n=st.PI_OVER_TWO-i*a,o[r++]=1-e*(1+Math.cos(n)),o[r++]=.5*(1+Math.sin(n));for(a=c-g;a>0;a--)o[r++]=a*e,o[r++]=1;for(a=1;a<s+1;a++)n=st.PI_OVER_TWO+i*a,o[r++]=e*(1+Math.cos(n)),o[r++]=.5*(1+Math.sin(n))}else{for(c/=3,f/=3,e=1/(c-1),t=1/(f-1),a=0;a<f;a++)o[r++]=a*t,o[r++]=0;for(a=c;a>0;a--)o[r++]=(a-1)*e,o[r++]=1}h.st=new x({componentDatatype:F.FLOAT,componentsPerAttribute:2,values:o})}return e.normal&&(h.normal=new x({componentDatatype:F.FLOAT,componentsPerAttribute:3,values:P.normals})),e.tangent&&(h.tangent=new x({componentDatatype:F.FLOAT,componentsPerAttribute:3,values:P.tangents})),e.bitangent&&(h.bitangent=new x({componentDatatype:F.FLOAT,componentsPerAttribute:3,values:P.bitangents})),{attributes:h,indices:V}}function qt(t,e){if(!e.normal&&!e.tangent&&!e.bitangent&&!e.st)return t;let r,i,a=t.position.values;(e.normal||e.bitangent)&&(r=t.normal.values,i=t.bitangent.values);let n,s=t.position.values.length/18,l=3*s,u=2*s,d=2*l;if(e.normal||e.bitangent||e.tangent){let s=e.normal?new Float32Array(6*l):void 0,u=e.tangent?new Float32Array(6*l):void 0,m=e.bitangent?new Float32Array(6*l):void 0,h=zt,c=kt,f=wt,p=Tt,g=jt,A=Ht,b=d;for(n=0;n<l;n+=3){let t=b+d;h=o.fromArray(a,n,h),c=o.fromArray(a,n+l,c),f=o.fromArray(a,(n+3)%l,f),c=o.subtract(c,h,c),f=o.subtract(f,h,f),p=o.normalize(o.cross(c,f,p),p),e.normal&&(M.addAttribute(s,p,t),M.addAttribute(s,p,t+3),M.addAttribute(s,p,b),M.addAttribute(s,p,b+3)),(e.tangent||e.bitangent)&&(A=o.fromArray(r,n,A),e.bitangent&&(M.addAttribute(m,A,t),M.addAttribute(m,A,t+3),M.addAttribute(m,A,b),M.addAttribute(m,A,b+3)),e.tangent&&(g=o.normalize(o.cross(A,p,g),g),M.addAttribute(u,g,t),M.addAttribute(u,g,t+3),M.addAttribute(u,g,b),M.addAttribute(u,g,b+3))),b+=6}if(e.normal){for(s.set(r),n=0;n<l;n+=3)s[n+l]=-r[n],s[n+l+1]=-r[n+1],s[n+l+2]=-r[n+2];t.normal.values=s}else t.normal=void 0;if(e.bitangent?(m.set(i),m.set(i,l),t.bitangent.values=m):t.bitangent=void 0,e.tangent){let e=t.tangent.values;u.set(e),u.set(e,l),t.tangent.values=u}}if(e.st){let e=t.st.values,o=new Float32Array(6*u);o.set(e),o.set(e,u);let r=2*u;for(let t=0;t<2;t++){for(o[r++]=e[0],o[r++]=e[1],n=2;n<u;n+=2){let t=e[n],i=e[n+1];o[r++]=t,o[r++]=i,o[r++]=t,o[r++]=i}o[r++]=e[0],o[r++]=e[1]}t.st.values=o}return t}function Ot(t,e,o){o[e++]=t[0],o[e++]=t[1],o[e++]=t[2];for(let r=3;r<t.length;r+=3){let i=t[r],a=t[r+1],n=t[r+2];o[e++]=i,o[e++]=a,o[e++]=n,o[e++]=i,o[e++]=a,o[e++]=n}return o[e++]=t[0],o[e++]=t[1],o[e++]=t[2],o}function Gt(t,e){let o=new J({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),r=t.ellipsoid,i=M.computePositions(t),a=Bt(i,o,r),n=t.height,s=t.extrudedHeight,l=a.attributes,u=a.indices,d=l.position.values,m=d.length,h=new Float64Array(6*m),c=new Float64Array(m);c.set(d);let f=new Float64Array(4*m);d=yt.scaleToGeodeticHeight(d,n,r),f=Ot(d,0,f),c=yt.scaleToGeodeticHeight(c,s,r),f=Ot(c,2*m,f),h.set(d),h.set(c,m),h.set(f,2*m),l.position.values=h,l=qt(l,e);let p,g=m/3;if(t.shadowVolume){let t=l.normal.values;m=t.length;let o=new Float32Array(6*m);for(p=0;p<m;p++)t[p]=-t[p];o.set(t,m),o=Ot(t,4*m,o),l.extrudeDirection=new x({componentDatatype:F.FLOAT,componentsPerAttribute:3,values:o}),e.normal||(l.normal=void 0)}if(X(t.offsetAttribute)){let e=new Uint8Array(6*g);if(t.offsetAttribute===_t.TOP)e=e.fill(1,0,g).fill(1,2*g,4*g);else{let o=t.offsetAttribute===_t.NONE?0:1;e=e.fill(o)}l.applyOffset=new x({componentDatatype:F.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let A=u.length,b=g+g,y=Nt.createTypedArray(h.length/3,2*A+3*b);y.set(u);let _,w,v,T,I=A;for(p=0;p<A;p+=3){let t=u[p],e=u[p+1],o=u[p+2];y[I++]=o+g,y[I++]=e+g,y[I++]=t+g}for(p=0;p<b;p+=2)_=p+b,w=_+b,v=_+1,T=w+1,y[I++]=_,y[I++]=w,y[I++]=v,y[I++]=v,y[I++]=w,y[I++]=T;return{attributes:l,indices:y}}var Dt=new o,gt=new o,Q=new bt;function Rt(t,e,r,i,a,n){let s=o.subtract(e,t,Dt);o.normalize(s,s);let l=r.geodeticSurfaceNormal(t,gt),u=o.cross(s,l,Dt);o.multiplyByScalar(u,i,u);let d=a.latitude,m=a.longitude,h=n.latitude,c=n.longitude;o.add(t,u,gt),r.cartesianToCartographic(gt,Q);let f=Q.latitude,p=Q.longitude;d=Math.min(d,f),m=Math.min(m,p),h=Math.max(h,f),c=Math.max(c,p),o.subtract(t,u,gt),r.cartesianToCartographic(gt,Q),f=Q.latitude,p=Q.longitude,d=Math.min(d,f),m=Math.min(m,p),h=Math.max(h,f),c=Math.max(c,p),a.latitude=d,a.longitude=m,n.latitude=h,n.longitude=c}var K=new o,pt=new o,W=new bt,j=new bt;function Yt(t,e,r,i,a){t=Ut(t,e);let n=Pt(t,o.equalsEpsilon),s=n.length;if(s<2||r<=0)return new Et;let l,u,d=.5*r;if(W.latitude=Number.POSITIVE_INFINITY,W.longitude=Number.POSITIVE_INFINITY,j.latitude=Number.NEGATIVE_INFINITY,j.longitude=Number.NEGATIVE_INFINITY,i===ht.ROUNDED){let t=n[0];o.subtract(t,n[1],K),o.normalize(K,K),o.multiplyByScalar(K,d,K),o.add(t,K,pt),e.cartesianToCartographic(pt,Q),l=Q.latitude,u=Q.longitude,W.latitude=Math.min(W.latitude,l),W.longitude=Math.min(W.longitude,u),j.latitude=Math.max(j.latitude,l),j.longitude=Math.max(j.longitude,u)}for(let o=0;o<s-1;++o)Rt(n[o],n[o+1],e,d,W,j);let m=n[s-1];o.subtract(m,n[s-2],K),o.normalize(K,K),o.multiplyByScalar(K,d,K),o.add(m,K,pt),Rt(m,pt,e,d,W,j),i===ht.ROUNDED&&(e.cartesianToCartographic(pt,Q),l=Q.latitude,u=Q.longitude,W.latitude=Math.min(W.latitude,l),W.longitude=Math.min(W.longitude,u),j.latitude=Math.max(j.latitude,l),j.longitude=Math.max(j.longitude,u));let h=X(a)?a:new Et;return h.north=j.latitude,h.south=W.latitude,h.east=j.longitude,h.west=W.longitude,h}function et(t){t=B(t,B.EMPTY_OBJECT);let e=t.positions,r=t.width;it.defined("options.positions",e),it.defined("options.width",r);let i=B(t.height,0),a=B(t.extrudedHeight,i);this._positions=e,this._ellipsoid=I.clone(B(t.ellipsoid,I.WGS84)),this._vertexFormat=J.clone(B(t.vertexFormat,J.DEFAULT)),this._width=r,this._height=Math.max(i,a),this._extrudedHeight=Math.min(i,a),this._cornerType=B(t.cornerType,ht.ROUNDED),this._granularity=B(t.granularity,st.RADIANS_PER_DEGREE),this._shadowVolume=B(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*o.packedLength+I.packedLength+J.packedLength+7}et.pack=function(t,e,r){it.defined("value",t),it.defined("array",e),r=B(r,0);let i=t._positions,a=i.length;e[r++]=a;for(let n=0;n<a;++n,r+=o.packedLength)o.pack(i[n],e,r);return I.pack(t._ellipsoid,e,r),r+=I.packedLength,J.pack(t._vertexFormat,e,r),r+=J.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=B(t._offsetAttribute,-1),e};var It=I.clone(I.UNIT_SPHERE),Wt=new J,tt={positions:void 0,ellipsoid:It,vertexFormat:Wt,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};et.unpack=function(t,e,r){it.defined("array",t),e=B(e,0);let i=t[e++],a=new Array(i);for(let p=0;p<i;++p,e+=o.packedLength)a[p]=o.unpack(t,e);let n=I.unpack(t,e,It);e+=I.packedLength;let s=J.unpack(t,e,Wt);e+=J.packedLength;let l=t[e++],u=t[e++],d=t[e++],m=t[e++],h=t[e++],c=1===t[e++],f=t[e];return X(r)?(r._positions=a,r._ellipsoid=I.clone(n,r._ellipsoid),r._vertexFormat=J.clone(s,r._vertexFormat),r._width=l,r._height=u,r._extrudedHeight=d,r._cornerType=m,r._granularity=h,r._shadowVolume=c,r._offsetAttribute=-1===f?void 0:f,r):(tt.positions=a,tt.width=l,tt.height=u,tt.extrudedHeight=d,tt.cornerType=m,tt.granularity=h,tt.shadowVolume=c,tt.offsetAttribute=-1===f?void 0:f,new et(tt))},et.computeRectangle=function(t,e){t=B(t,B.EMPTY_OBJECT);let o=t.positions,r=t.width;it.defined("options.positions",o),it.defined("options.width",r);let i=B(t.ellipsoid,I.WGS84),a=B(t.cornerType,ht.ROUNDED);return Yt(o,i,r,a,e)},et.createGeometry=function(t){let e=t._positions,r=t._width,i=t._ellipsoid;e=Ut(e,i);let a=Pt(e,o.equalsEpsilon);if(a.length<2||r<=0)return;let n,s=t._height,l=t._extrudedHeight,u=!st.equalsEpsilon(s,l,0,st.EPSILON2),d=t._vertexFormat,m={ellipsoid:i,positions:a,width:r,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};if(u)m.height=s,m.extrudedHeight=l,m.shadowVolume=t._shadowVolume,m.offsetAttribute=t._offsetAttribute,n=Gt(m,d);else{let e=M.computePositions(m);if(n=Bt(e,d,i),n.attributes.position.values=yt.scaleToGeodeticHeight(n.attributes.position.values,s,i),X(t._offsetAttribute)){let e=t._offsetAttribute===_t.NONE?0:1,o=n.attributes.position.values.length,r=new Uint8Array(o/3).fill(e);n.attributes.applyOffset=new x({componentDatatype:F.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}}let h=n.attributes,c=St.fromVertices(h.position.values,void 0,3);return d.position||(n.attributes.position.values=void 0),new Vt({attributes:h,indices:n.indices,primitiveType:Mt.TRIANGLES,boundingSphere:c,offsetAttribute:t._offsetAttribute})},et.createShadowVolume=function(t,e,o){let r=t._granularity,i=t._ellipsoid,a=e(r,i),n=o(r,i);return new et({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:r,extrudedHeight:a,height:n,vertexFormat:J.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(et.prototype,{rectangle:{get:function(){return X(this._rectangle)||(this._rectangle=Yt(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});var Lt=et;function Jt(t,e){return X(e)&&(t=Lt.unpack(t,e)),t._ellipsoid=I.clone(t._ellipsoid),Lt.createGeometry(t)}var Ae=Jt;export{Ae as default};